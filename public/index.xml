<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yucklys的小站</title>
    <link>https://www.yucklys.com/</link>
    <description>Recent content on Yucklys的小站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 05 Aug 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://www.yucklys.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Polybar Nord主题配置</title>
      <link>https://www.yucklys.com/post/i3-nord-theme/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/i3-nord-theme/</guid>
      
        <description>&lt;p&gt;最近迷上了 &lt;a href=&#34;https://www.nordtheme.com/&#34;&gt;Nord&lt;/a&gt; 配色，把我的终端、vim、以及 i3wm 的配色全部换成了Nord。不过 Polybar 我并没有找到合适的 Nord 配色，所以花了点时间，重新写了一遍配置，使用了 Nord 配色并且基本支持所有的官方 module 和一些社区以及本人写的 module。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tupp.xyz/2019/08/05/15650043555d481243502de.png&#34; alt=&#34;i3-nord.png&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;概况&#34;&gt;概况&lt;/h1&gt;

&lt;p&gt;支持的 module：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#alsa&#34;&gt;alsa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#backlight&#34;&gt;backlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#date&#34;&gt;date&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notify&#34;&gt;notify (基于dunst)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-detail&#34;&gt;network-detail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-short&#34;&gt;network-short&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#battery&#34;&gt;battery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#keyboard&#34;&gt;keyboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#systray&#34;&gt;systray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpd&#34;&gt;mpd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#i3&#34;&gt;i3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#workspace-name&#34;&gt;workspace-name&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weather&#34;&gt;weather&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#info-hackspeed&#34;&gt;info-hackspeed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#github&#34;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#daily-poem&#34;&gt;daily-poem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;temperature&#34;&gt;temperature&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#memory&#34;&gt;memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cpu&#34;&gt;cpu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#show-desktop&#34;&gt;show-desktop&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;必需依赖：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.archlinux.org/packages/community/any/ttf-font-awesome/&#34;&gt;Font Awesome&lt;/a&gt; （必选）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可选依赖：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/erikflowers/weather-icons&#34;&gt;Weather Icon&lt;/a&gt;（weather 组件需要）&lt;/li&gt;
&lt;li&gt;Dunst （notify 组件显示历史通知需要）&lt;/li&gt;
&lt;li&gt;redshift （backlight 开关 redshift 功能）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;配置放在了 &lt;a href=&#34;https://github.com/Yucklys/polybar-nord-theme&#34;&gt;GitHub&lt;/a&gt; 上，clone 到自己的 Polybar 配置文件夹下替换即可，建议提前做好备份。`&lt;/p&gt;

&lt;p&gt;前排提示，配合&lt;a href=&#34;https://github.com/polybar/polybar/wiki&#34;&gt;官方wiki&lt;/a&gt;食用口味更佳。&lt;/p&gt;

&lt;h1 id=&#34;modules&#34;&gt;Modules&lt;/h1&gt;

&lt;h2 id=&#34;alsa&#34;&gt;alsa&lt;/h2&gt;

&lt;p&gt;显示当前音量，根据音量共有三种不同颜色图标。默认声卡选择为&lt;code&gt;default&lt;/code&gt;，可以在&lt;code&gt;nord-config&lt;/code&gt;里调整声卡选项。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;静音/恢复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮上&lt;/td&gt;
&lt;td&gt;音量 +，每次 +5%&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮下&lt;/td&gt;
&lt;td&gt;音量 -，每次 -5%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;backlight&#34;&gt;backlight&lt;/h2&gt;

&lt;p&gt;调整屏幕亮度。可选左击开关 redshift，需要提前配置好 redshift 或者修改 scripts/&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;滚轮上&lt;/td&gt;
&lt;td&gt;亮度 +，每次 +5%&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮下&lt;/td&gt;
&lt;td&gt;亮度 -，每次 -5%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;date&#34;&gt;date&lt;/h2&gt;

&lt;p&gt;显示时间。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;切换日期/时间显示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;notify&#34;&gt;notify&lt;/h2&gt;

&lt;p&gt;通知图标。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;模拟 ctrl+grave，即默认的 dunst 历史快捷键，会被其他快捷键设定覆盖&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;network-detail&#34;&gt;network-detail&lt;/h2&gt;

&lt;p&gt;显示上传及下载速度，单位为KB/s，需要在&lt;code&gt;nord-config&lt;/code&gt;中&lt;code&gt;interface&lt;/code&gt;字段设置自己的 interface。&lt;/p&gt;

&lt;h2 id=&#34;network-short&#34;&gt;network-short&lt;/h2&gt;

&lt;p&gt;显示网络连接图标，图标颜色代表网络连接延迟程度，颜色越偏红说明延迟越高。&lt;/p&gt;

&lt;h2 id=&#34;battery&#34;&gt;battery&lt;/h2&gt;

&lt;p&gt;显示电池信息，需要在&lt;code&gt;nord-config&lt;/code&gt;中设置&lt;code&gt;battery-full-at&lt;/code&gt;、&lt;code&gt;battery-bat&lt;/code&gt;以及&lt;code&gt;battery-adp&lt;/code&gt;字段。&lt;/p&gt;

&lt;h2 id=&#34;keyboard&#34;&gt;keyboard&lt;/h2&gt;

&lt;p&gt;显示键盘大写锁定。因为使用的键盘没有 NumLock，所以暂时不支持，如果需要可以自行添加。&lt;/p&gt;

&lt;h2 id=&#34;systray&#34;&gt;systray&lt;/h2&gt;

&lt;p&gt;显示系统托盘。我的系统是 Manjaro i3 社区版，i3 版本 4.16.1，polybar 版本 3.4.0，按照如此配置没有产生显示错误。如果遇到问题可以到官方 issue 中查找，有图标问题的人挺多的。&lt;/p&gt;

&lt;h2 id=&#34;mpd&#34;&gt;mpd&lt;/h2&gt;

&lt;p&gt;显示 mpd 信息，当 mpd 进程不存在时隐藏。总共有三种显示方式，分别为&lt;strong&gt;播放中&lt;/strong&gt;、&lt;strong&gt;暂停&lt;/strong&gt;以及&lt;strong&gt;停止&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;播放状态下显示全部内容，包括*暂停*、*上一首*、*歌手 - 歌名*、*下一首*、*停止*、*进度条*、*列表循环*以及*列表随机*。&lt;/li&gt;
&lt;li&gt;暂停状态下显示部分内容，包括*播放*、*上一首*、*歌手 - 歌名*、*下一首*、*停止*。&lt;/li&gt;
&lt;li&gt;停止状态下仅显示*播放*。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要在&lt;code&gt;nord-config&lt;/code&gt;中设置&lt;code&gt;mpd-host&lt;/code&gt;及&lt;code&gt;mpd-port&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;i3&#34;&gt;i3&lt;/h2&gt;

&lt;p&gt;显示 i3 workspace 图标，图标可在&lt;code&gt;nord-top&lt;/code&gt;中定义。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;i3-msg workspace &lt;index&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮上&lt;/td&gt;
&lt;td&gt;i3-msg workspace prev&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮下&lt;/td&gt;
&lt;td&gt;i3-msg workspace next&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;workspace-name&#34;&gt;workspace-name&lt;/h2&gt;

&lt;p&gt;显示当前 workspace 名字，在 i3 的配置文件处定义，格式为 &lt;code&gt;index:name&lt;/code&gt;，例如&lt;code&gt;1:Home&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;weather&#34;&gt;weather&lt;/h2&gt;

&lt;p&gt;显示 Openweather 天气信息，使用的脚本来自于&lt;a href=&#34;https://github.com/polybar/polybar-scripts/tree/master/polybar-scripts/openweathermap-fullfeatured&#34;&gt;polybar/polybar-scripts/openweather-fullfeatured&lt;/a&gt;，需要个人API及城市代码，在脚本中设置，具体情况可查看项目 Readme。&lt;/p&gt;

&lt;h2 id=&#34;info-hackspeed&#34;&gt;info-hackspeed&lt;/h2&gt;

&lt;p&gt;显示每分钟输入速度，单位默认为 cpm (char per minute)，可选 wpm (word per minute)，在脚本中设置。来自于&lt;a href=&#34;https://github.com/polybar/polybar-scripts/tree/master/polybar-scripts/info-hackspeed&#34;&gt;polybar/polybar-scripts/info-hackspeed&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;daily-poem&#34;&gt;daily-poem&lt;/h2&gt;

&lt;p&gt;显示今日诗词，使用了 V友@lhx2008 分享的&lt;a href=&#34;https://www.jinrishici.com/&#34;&gt;今日诗词 API&lt;/a&gt;，支持显示诗词推荐、来源以及匹配标签。使用需要获取 token，可到 &lt;a href=&#34;https://v2.jinrishici.com/token&#34;&gt;https://v2.jinrishici.com/token&lt;/a&gt; 获取 token 后替换我在&lt;code&gt;nord-down&lt;/code&gt;中的 token。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;显示诗词内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮上&lt;/td&gt;
&lt;td&gt;显示诗词来源&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;滚轮下&lt;/td&gt;
&lt;td&gt;显示匹配标签&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;鼠标右击&lt;/td&gt;
&lt;td&gt;更新诗词&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;temperature&#34;&gt;temperature&lt;/h2&gt;

&lt;p&gt;显示温度，可在&lt;code&gt;nord-config&lt;/code&gt;中设置&lt;code&gt;thermal-zone&lt;/code&gt;，默认为0。当温度低于&lt;code&gt;base-temperature&lt;/code&gt;时切换为最低温度显示，当温度高于&lt;code&gt;warn-temperature&lt;/code&gt;时切换为警戒温度显示，温度图标颜色会根据温度在&lt;code&gt;base-temperature&lt;/code&gt;到&lt;code&gt;warn-temperature&lt;/code&gt;之间变化，根据自身情况设置合理的值即可。&lt;/p&gt;

&lt;h2 id=&#34;memory&#34;&gt;memory&lt;/h2&gt;

&lt;p&gt;显示内存使用情况，格式为 used/total。&lt;/p&gt;

&lt;h2 id=&#34;cpu&#34;&gt;cpu&lt;/h2&gt;

&lt;p&gt;显示 cpu 使用情况。&lt;/p&gt;

&lt;h2 id=&#34;show-desktop&#34;&gt;show-desktop&lt;/h2&gt;

&lt;p&gt;显示桌面。默认是切换到&lt;code&gt;25:Desktop&lt;/code&gt;，可在&lt;code&gt;nord-down&lt;/code&gt;中调整。如果 i3wm 启动了 workspace back_and_forth 的话，两次左击可返回原来桌面。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;绑定&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;鼠标左击&lt;/td&gt;
&lt;td&gt;i3-msg workspace 25:Desktop&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;结语&#34;&gt;结语&lt;/h1&gt;

&lt;p&gt;除了 Polybar，我还写了 rofi，i3 以及 dunst 的配置，有时间再整理整理发出来吧。干这活的确挺繁琐的，Polybar 的配置难度算是比较低的了，官方的 wiki 简单易懂，不需要什么学什么额外的东西。其实还有一些细节处可以调整一下，比如歌手名和歌名的样式分开，不过这需要声明一个环境变量，对于通用的配置来说过于复杂了，所以个人配置我自己再琢磨琢磨，给大家一份开箱即用的配置就可以了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://www.yucklys.com/about/</link>
      <pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/about/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;使用了 &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 生成的博客，并使用 &lt;a href=&#34;https://github.com/nanxiaobei/hugo-paper&#34;&gt;Paper&lt;/a&gt; 为主题&lt;/li&gt;
&lt;li&gt;折腾的路永无止境&lt;/li&gt;
&lt;li&gt;年方十八&lt;/li&gt;
&lt;li&gt;坐标北京&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Yucklys/&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>在 React 中引入 Electron</title>
      <link>https://www.yucklys.com/post/electron%E4%B8%8Ereact%E7%BB%93%E5%90%88/</link>
      <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/electron%E4%B8%8Ereact%E7%BB%93%E5%90%88/</guid>
      
        <description>&lt;p&gt;最近体验了一下 Electron，迫不及待的换上了我心爱的 React，仿佛看见了新世界，但是当我试图&lt;code&gt;import { ipcRenderer } from &#39;electron&#39;&lt;/code&gt;会报错 &lt;code&gt;TypeError: fs.existsSync is not a function&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;webpack-target属性&#34;&gt;Webpack target属性&lt;/h2&gt;

&lt;p&gt;webpack 的&lt;code&gt;target: electron-renderer&lt;/code&gt;属性能够很好的解决这个问题。这里展示的是改造&lt;code&gt;create-react-app&lt;/code&gt;的方法，其他脚手架诸如此类。&lt;/p&gt;

&lt;p&gt;项目新建好后，首先一发&lt;code&gt;yarn eject&lt;/code&gt;展开所有配置，在多出来的config文件夹下就有我们需要更改的&lt;code&gt;webpack.config.js&lt;/code&gt;文件。&lt;code&gt;create-react-app&lt;/code&gt;在基础的webpack配置上添加了很多内容，比如说环境检测以及sass，不过我们这里直接在return里添加target属性，如果想要根据develop或product环境切换target的话可以自行添加。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// other configs...
module.exports = function(webpackEnv) {
// some configs
    return {
        target: &#39;electron-renderer&#39;, // 添加target
        // other configs
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，现在我们再运行&lt;code&gt;yarn start&lt;/code&gt;的话，会发现通过浏览器无法打开&lt;code&gt;localhost:3000&lt;/code&gt;了。接下来在根目录新建Electron主程序入口&lt;code&gt;main.js&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const { app, BrowserWindow } = require(&#39;electron&#39;);

// 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被
// 垃圾回收的时候，window对象将会自动的关闭
let win;

function createWindow() {
	// 创建浏览器窗口。
	win = new BrowserWindow({ width: 800, height: 600 });

	// 然后加载应用的 index.html。
	// win.loadFile(&#39;index.html&#39;);
	// 这里没有选择官方的从文件加载的方法，而是选择从localhost加载
	win.loadURL(&#39;http://localhost:3000&#39;);

	// 打开开发者工具
	win.webContents.openDevTools();

	// 当 window 被关闭，这个事件会被触发。
	win.on(&#39;closed&#39;, () =&amp;gt; {
		// 取消引用 window 对象，如果你的应用支持多窗口的话，
		// 通常会把多个 window 对象存放在一个数组里面，
		// 与此同时，你应该删除相应的元素。
		win = null;
	});
}

// Electron 会在初始化后并准备
// 创建浏览器窗口时，调用这个函数。
// 部分 API 在 ready 事件触发后才能使用。
app.on(&#39;ready&#39;, createWindow);

// 当全部窗口关闭时退出。
app.on(&#39;window-all-closed&#39;, () =&amp;gt; {
	// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，
	// 否则绝大部分应用及其菜单栏会保持激活。
	if (process.platform !== &#39;darwin&#39;) {
		app.quit();
	}
});

app.on(&#39;activate&#39;, () =&amp;gt; {
	// 在macOS上，当单击dock图标并且没有其他窗口打开时，
	// 通常在应用程序中重新创建一个窗口。
	if (win === null) {
		createWindow();
	}
});

// 在这个文件中，你可以续写应用剩下主进程代码。
// 也可以拆分成几个文件，然后用 require 导入。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时更改&lt;code&gt;package.json&lt;/code&gt;，加入&lt;code&gt;main: &amp;quot;main.js&amp;quot;&lt;/code&gt;，&lt;code&gt;homepage: &amp;quot;./&amp;quot;&lt;/code&gt;，同时在scripts中添加&lt;code&gt;&amp;quot;electron&amp;quot;: &amp;quot;electron .&amp;quot;&lt;/code&gt;，不要忘记&lt;code&gt;yarn add electron&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;准备工作完成之后，可以写一个小例子来测试一下渲染进程以及主进程的通信。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 在这个文件中，你可以续写应用剩下主进程代码。
// 也可以拆分成几个文件，然后用 require 导入。
const { ipcMain } = require(&#39;electron&#39;);

ipcMain.on(&#39;react-test&#39;, (event, arg) =&amp;gt; {
	console.log(`get ${arg} from Renderer process.`);
	event.sender.send(&#39;main-process-reply&#39;, &#39;world&#39;);
}); // 接收到react-test信号后返回main-process-reply并打印&#39;get ${arg} from Renderer process&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const { ipcRenderer } = require(&#39;electron&#39;);

class App extends {
    componentDidMount() {
        ipcRenderer.send(&#39;react-test&#39;, &#39;Hello&#39;); // 发送react-test信号，同时arg为&#39;Hello&#39;

        ipcRenderer.on(&#39;main-process-reply&#39;, (_event, arg) =&amp;gt; {
            console.log(`Hello ${arg}`);
        }); // 接收main-process-reply并打印arg
    }

    render() {
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来依次运行&lt;code&gt;yarn start&lt;/code&gt;以及&lt;code&gt;yarn electron&lt;/code&gt;，在终端以及electron应用的控制台应该都可以看到打印出的信息，通信成功！&lt;/p&gt;

&lt;h2 id=&#34;preload提前引入electron&#34;&gt;Preload提前引入electron&lt;/h2&gt;

&lt;p&gt;利用webpack的target属性确实是最稳妥，最官方的解决方案了，但是对于一些高度封装webpack并且没有eject选项的脚手架来说，就无法通过target属性来简单解决了。这里使用的是&lt;code&gt;dva new --demo&lt;/code&gt;新建的一个项目，我们会在主进程中提前引入我们需要的包以达到在渲染进程中使用的目的。&lt;/p&gt;

&lt;p&gt;首先开始的步骤同上，安装electron并且新建main.js，在主进程文件main.js中写入我们之前用过的测试例子，同时做一些修改。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function createWindow() {
  win = new BrowserWindow({
    width: 800,
    height: 600,
    webPreferences: {
      preload: __dirname + &#39;/preload.js&#39;
    }
  });

  win.loadURL(&#39;http://localhost:8000&#39;); // Roadhog默认的localhost端口为8000
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们在preload选项中引用了根目录下在preload.js文件，在该文件中写入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;global.electron = require(&#39;electron&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，现在我们修改&lt;code&gt;src/index.js&lt;/code&gt;文件，就可以实现进程间通讯了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// ...
// 3. Router
class HomePage extends React.Component {
  componentDidMount() {
    const { ipcRenderer } = window.electron;
    ipcRenderer.send(&#39;react-test&#39;, &#39;Hello&#39;);
    ipcRenderer.on(&#39;main-process-reply&#39;, (_event, arg) =&amp;gt; {
      console.log(`Hello, ${arg}`);
    });
  }

  render() {
    return &amp;lt;div&amp;gt;Hello, world!&amp;lt;/div&amp;gt;;
  }
}
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这种方式，在浏览器中打开的话会报错，无法引用ipcRenderer，但是如果通过electron打开的话就可以正常地进行通讯了。而且通过&lt;code&gt;preload: &#39;file&#39;&lt;/code&gt;这种方式，我们还可以很方便地把一些设置全局共享，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const os = require(&#39;os&#39;);
const path = require(&#39;path&#39;);

global.path = path.join(os.homedir(), &#39;.config&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;除开这两种自己动手的方法以外，在 GitHub 上还有各种xxx-electron-boilerplate可供使用，不过有些年代比较久远，并且年久失修，issue 没人处理，很多依赖都落后几个版本了，反而不是很好用。当然，&lt;a href=&#34;https://github.com/electron-react-boilerplate/electron-react-boilerplate&#34;&gt;electron-react-boilerplate&lt;/a&gt;这个1w star项目现在还是很活跃的，比起自己这样凑活着搭起来的框架更成体系。具体是怎么样的结合就看自己项目的需求了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>React 滚动事件监听</title>
      <link>https://www.yucklys.com/post/react-scroll/</link>
      <pubDate>Mon, 19 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/react-scroll/</guid>
      
        <description>&lt;p&gt;对于多页面的网站来说，一个导航栏是必不可少的。现在常用的一些 64 px 高度的导航栏占用的空间对于一些展示型网站来说就有点过于大了。为了能够节省下这部分空间益达到完美的图像展示空间，我们需要在适当的时候隐藏导航栏。&lt;/p&gt;

&lt;h2 id=&#34;自动隐藏header&#34;&gt;自动隐藏Header&lt;/h2&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;首先还是以&lt;code&gt;create-react-app&lt;/code&gt;作为框架，在终端下输入&lt;code&gt;create-react-app react-scroll&lt;/code&gt;创建项目文件夹，创建完成后进入文件夹输入&lt;code&gt;npm start&lt;/code&gt;，如果顺利的话此时已经可以在&lt;code&gt;localhost:3000&lt;/code&gt;看见初始的应用界面了。&lt;/p&gt;

&lt;p&gt;首先先改一下源文件，修改header并且加上一个足够长的内容(2000px)，让页面可以滚动足够的距离。这里为了节约篇幅，只放上需要改动的部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//......
class App extends Component {
  render() {
    return (
      &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt;
        &amp;lt;header className=&amp;quot;App-header&amp;quot;&amp;gt;
          Header1
        &amp;lt;/header&amp;gt;
        &amp;lt;div className=&amp;quot;App-container&amp;quot; /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
//......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的css文件也需要改一下，同上，这里的代码只是需要改动的部分，未在这里贴出的代码不需要调整。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.App-header {
  position: fixed; /*固定header*/
  top: 0px;
  width: 100%;
  min-height: 64px;
}

.App-container {
  margin: 70px;
  width: auto;
  height: 2000px;
  border-radius: 10px;
  background-color: rgba(126, 248, 238, 0.856);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的页面应该是这个样子，现在我们可以进行下一步的修改，让header能随着我们的滚动而消失或浮现。&lt;img src=&#34;https://i.loli.net/2018/11/19/5bf2b0528ee57.gif&#34; alt=&#34;初始化&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;添加滚动事件监听及判断&#34;&gt;添加滚动事件监听及判断&lt;/h3&gt;

&lt;h4 id=&#34;滚动事件监听&#34;&gt;滚动事件监听&lt;/h4&gt;

&lt;p&gt;现在我们需要加入对滚动事件的监控来获取滚动数据。在这个例子里使用的是&lt;code&gt;window.addEventLister(&#39;scroll&#39;, function() {})&lt;/code&gt;方法，这个方法接受两个参数，&lt;code&gt;event&lt;/code&gt;和&lt;code&gt;function&lt;/code&gt;，针对我们这个例子的话分别是&lt;code&gt;scroll&lt;/code&gt;事件并且绑定为&lt;code&gt;handleScroll&lt;/code&gt;函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class App extends Component {
    componentDidMount() {
        window.addEventLister(&#39;scroll&#39;, handleScroll);
    }
    
    handleScroll() {
        console.log(&#39;scroll&#39;);
    }
    
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf622abc976d.gif&#34; alt=&#34;滚动初体验&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;滚动事件判断&#34;&gt;滚动事件判断&lt;/h4&gt;

&lt;p&gt;现在知道了我们的页面什么时候滚动，那怎么判断我们滚动的方向呢？当添加&lt;code&gt;window.addEventListener&lt;/code&gt;并把&lt;code&gt;scroll&lt;/code&gt;事件绑定到&lt;code&gt;handleScroll&lt;/code&gt;之后，就可以通过&lt;code&gt;window.scrollY&lt;/code&gt;获取现在滚动的位置距离&lt;strong&gt;页面顶部&lt;/strong&gt;有多远&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class App extends Component {
    //...
    handleScroll() {
        console.log(window.scrollY)
    }
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf625cf80f86.gif&#34; alt=&#34;Y轴座标&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那如何通过这个参数判断滚动方向呢？假设说我们有一个&lt;code&gt;prevScroll&lt;/code&gt;的变量，保存着我们之前页面所在的Y轴座标，那么我们通过&lt;code&gt;window.scrollY - prevScroll&lt;/code&gt;就可以判断滚动方向了。如果这个数值为正，则为向下滚动；如果这个数值为负，则为向上滚动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf6295d240f0.png&#34; alt=&#34;滚动判断&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果对React足够熟悉的话应该立马就想到了&lt;code&gt;this.state&lt;/code&gt;。现在我们创建一个&lt;code&gt;this.state.prevScroll&lt;/code&gt;用来储存上一次的页面滚动位置，然后在每一次&lt;code&gt;handleScroll&lt;/code&gt;进行完判断之后更新&lt;code&gt;this.state.prevScroll&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            prevScroll: 0 //初始化prevScroll
        }
    }
    //...
    //滚动判断
    handleScroll() {
        const { prevScroll } = this.state;
        const changeY = window.scrollY;
        
        if (changeY &amp;gt;= 0) {
            console.log(&#39;scroll downward&#39;)
        } else {
            console.log(&#39;scroll upward&#39;)
        }
        
        this.setState({ prevScroll: window.scrollY })
    }
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf63ee2a7bfa.gif&#34; alt=&#34;滚动判断&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在通过同样的原理，把header的style属性指定为&lt;code&gt;this.state.headerStyle&lt;/code&gt;，在滚动判断中添加适当的内容，就可以实现根据页面滚动显示或隐藏元素了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf68cd4f4147.gif&#34; alt=&#34;滚动显示/隐藏header&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;一些优化&#34;&gt;一些优化&lt;/h4&gt;

&lt;p&gt;细心的人可能发现了，我们这个组件反复渲染了多次，如果在&lt;code&gt;render&lt;/code&gt;函数下加入一个&lt;code&gt;console.log(&#39;render&#39;)&lt;/code&gt;的话，就可以看到对于每一个scroll事件的变化，我们的组件都渲染了两次，而且同样是scroll downward，依然进行了渲染，这样子的话有可能对性能造成不必要的负担。所以这里加上&lt;code&gt;shouldComponentUpdate&lt;/code&gt;函数来判断什么时候进行渲染。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            prevScroll: 0,
            currentDirection: 0,
            headerStyle: {}
        };
    }
    //...
    shouldComponentUpdate(nextProps, nextState) {
        return (nextState.currentDirection !== this.state.currentDirection)
    }
    
    componentWillUnmount() {
        window.removeEventListener(&#39;scroll&#39;, this.handleScroll.bind(this));
    }
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/22/5bf6ab0d794ca.gif&#34; alt=&#34;优化滚动显示&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;最后&#34;&gt;最后&lt;/h3&gt;

&lt;p&gt;当然，这里的demo只是一个最简单的版本，实际上在这个例子的基础上还可以添加更多的条件判断，并且&lt;code&gt;scroll&lt;/code&gt;事件的函数也不止&lt;code&gt;scrollY&lt;/code&gt;，善用这些事件监听可以让你的页面更加地灵活。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;当然与之相对还有&lt;code&gt;window.scrollX&lt;/code&gt;，监控现在滚动位置距离页面左侧有多远。
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>搬家！GitHub Pages 关联域名</title>
      <link>https://www.yucklys.com/post/%E6%90%AC%E5%AE%B6github-page%E5%85%B3%E8%81%94%E5%9F%9F%E5%90%8D/</link>
      <pubDate>Mon, 05 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/%E6%90%AC%E5%AE%B6github-page%E5%85%B3%E8%81%94%E5%9F%9F%E5%90%8D/</guid>
      
        <description>&lt;p&gt;最近有时间上 &lt;a href=&#34;https://www.godaddy.com/&#34;&gt;Godaddy&lt;/a&gt; 购进了一个新域名，&lt;a href=&#34;https://yucklys.com/&#34;&gt;yucklys.com&lt;/a&gt;，一番折腾之后总算是摆脱了 github.io ，特此做一个记录。&lt;/p&gt;

&lt;h2 id=&#34;服务选择&#34;&gt;服务选择&lt;/h2&gt;

&lt;p&gt;由于不想去备案，并且实际上这个博客也没多少人看，所以选择了&lt;strong&gt;狗爹&lt;/strong&gt;的域名。狗爹的&lt;code&gt;.com&lt;/code&gt;域名还是很良心的，因为我们的https通过GitHub就可以开启，所以不用额外购买服务，而且还不需要实名认证，所以相对起来还是选择了狗爹。&lt;/p&gt;

&lt;p&gt;具体域名怎么购买我就不赘述了，点击上方Godaddy的链接即可进入主界面，注册帐号，搜索域名，找到心仪的域名就收入囊中吧！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;喝一杯咖啡，休息一下☕️。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一切都准备就绪了的话，开始搬家吧！&lt;/p&gt;

&lt;h2 id=&#34;搬家&#34;&gt;搬家&lt;/h2&gt;

&lt;h3 id=&#34;github-cname配置&#34;&gt;GitHub CNAME配置&lt;/h3&gt;

&lt;p&gt;首先打开博客在GitHub上的地址，比如&lt;a href=&#34;https://github.com/Yucklys/yucklys.github.io。在setting-GitHub&#34;&gt;https://github.com/Yucklys/yucklys.github.io。在setting-GitHub&lt;/a&gt; Pages选项下面可以看到如下的提示：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your site is published at &lt;a href=&#34;https://yourname.github.io/&#34;&gt;https://yourname.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这表明你的博客现在在yourname.github.io域名下运行着呢，现在我们需要做的就是设置一个cname记录把我们的新域名，yourname.com，添加进去。&lt;/p&gt;

&lt;p&gt;在GitHub Pages相关选项中有一个&lt;strong&gt;Custom Domain&lt;/strong&gt;选项，填写我们的域名，然后点击旁边的&lt;strong&gt;Save&lt;/strong&gt;。如果一切顺利的话，在刷新后GitHub Pages下方的提示应该变成了：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your site is published at &lt;a href=&#34;http://yourname.com/&#34;&gt;http://yourname.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;godaddy域名解析&#34;&gt;Godaddy域名解析&lt;/h3&gt;

&lt;p&gt;现在让我们转移到我们的域名控制台上进行域名的解析操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/06/5be10e1559b33.png&#34; alt=&#34;domain_name.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在Godaddy的域名管理台下需要修改的只有两处：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修改A记录，记录值改为GitHub Page的IP地址。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意，如果想给自己的博客加上小绿锁的话，这里的IP地址是&lt;strong&gt;GitHu Page的HTTPS地址&lt;/strong&gt;。总共有四个IP地址可选，随便选择一个就好了。&lt;a href=&#34;https://help.github.com/articles/setting-up-an-apex-domain/&#34;&gt;官方文档&lt;/a&gt;已经给出了颇为详细的介绍。四个IP如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;185.199.108.153
185.199.109.153
185.199.110.153
185.199.111.153
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;添加一个CNAME记录，把yourname.github.io添加进去。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这一步没什么需要注意的，如图填写即可。&lt;/p&gt;

&lt;p&gt;好了，现在输入你的域名，应该就可以访问你放在GitHub上的博客内容了。&lt;/p&gt;

&lt;h3 id=&#34;开启https&#34;&gt;开启HTTPS&lt;/h3&gt;

&lt;p&gt;眼尖的同学就发现了，现在我们的网站只开启了http，如果是用chrome浏览的话还会被标上恼人的「不安全」。要想开启Https的话其实很简单，眼尖的同学可能也发现了，在第一步修改GitHub Page的设置的时候，有一个选项叫做&lt;strong&gt;Enforce HTTPS&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.github.com/assets/img/2018-05-01-github-pages-custom-domains-enforce-https.png&#34; alt=&#34;Enforce HTTPS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;只需要简单地选中选项，页面刷新后就可以看到上方的提示变为：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Your site is published at &lt;a href=&#34;https://yourname.com/&#34;&gt;https://yourname.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是也有可能发生一些莫名的报错，我的HTTPS无法正常使用，经过多方调查，我在GitHub文档上看到了这样一句话：&lt;img src=&#34;https://i.loli.net/2018/11/06/5be114e1ef53e.png&#34; alt=&#34;resolve http.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后我先删除了我的&lt;strong&gt;Custom Domain&lt;/strong&gt;设置，保存，然后再重新添加，保存，然后&lt;strong&gt;Enforce HTTPS&lt;/strong&gt;就可以使用了。不是很清楚是什么原理，不过这样做确实是解决了我的问题。&lt;/p&gt;

&lt;p&gt;等待一段时间后，就可以看到自己的Https博客了😄 。&lt;/p&gt;

&lt;h3 id=&#34;本地配置&#34;&gt;本地配置&lt;/h3&gt;

&lt;p&gt;但是需要注意的是，GitHub Page的CNAME选项只是在项目文件夹下新建了一个CNAME(无后缀)文件，如果在本地的git项目中没有这个文件的话，下一次deploy就会把这个文件删除，导致我们需要重新配置一遍。所以在本地上的源文件内需要也新建一个CNAME文件，内容仿照GitHub中生成的CNAME文件就行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;domainname.com
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Vultr 与小飞机</title>
      <link>https://www.yucklys.com/post/install-ss-with-vultr/</link>
      <pubDate>Fri, 17 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/install-ss-with-vultr/</guid>
      
        <description>&lt;p&gt;多的不说了，标题已经不言而喻。&lt;/p&gt;

&lt;h2 id=&#34;什么是shadowsocks&#34;&gt;什么是shadowsocks?&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Shadowsocks&lt;/strong&gt; 可以指：一种基于 &lt;a href=&#34;https://zh.wikipedia.org/wiki/SOCKS#SOCK5&#34;&gt;Socks5&lt;/a&gt; 代理方式的加密传输协议，也可以指实现这个协议的各种传输包。 Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。&lt;/p&gt;

&lt;p&gt;摘自 &lt;a href=&#34;https://zh.wikipedia.org/wiki/Shadowsocks&#34;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要注意的一点是shadowsocks&lt;strong&gt;不是&lt;/strong&gt;vpn, 它只是一种基于&lt;strong&gt;SOCKS5协议&lt;/strong&gt;的对于网络请求的加密/解密方法, 以达到科学上网的目的.&lt;/p&gt;

&lt;h3 id=&#34;shadowsocks原理&#34;&gt;shadowsocks原理&lt;/h3&gt;

&lt;p&gt;一般情况下, 如果在本机上想要访问&lt;strong&gt;外网&lt;/strong&gt;(Google/Twitter/Youtube)是直接与远程服务建立连接并传输数据. 但在受限的网络环境下传输的数据会先经过&lt;strong&gt;防火墙(GFW)&lt;/strong&gt;的检查, 如果检查出传输内容包含受限内容的话, 就会阻止此次传输, 导致无法获取远程服务数据.&lt;/p&gt;

&lt;p&gt;而shadowsocks则是根据&lt;strong&gt;SOCKS5&lt;/strong&gt;协议封装的一种数据传输的方法.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从主机上发出的请求会先经过本地的&lt;strong&gt;ss客户端(ss-local)&lt;/strong&gt;, ss客户端会根据配置的加密方法与密码对原数据进行加密, 再将加密过的数据发送给GFW.&lt;/li&gt;
&lt;li&gt;由于数据经过了加密, GFW无法识别出该请求是否受限, 于是通过此次请求.&lt;/li&gt;
&lt;li&gt;按照用户配置的内容, 该被加密的数据会先发送到&lt;strong&gt;境外的ss服务端(ss-server)&lt;/strong&gt;, 通过同样的算法解密后得到真正的请求数据, 然后从指定的服务器获取返回数据.&lt;/li&gt;
&lt;li&gt;最后通过类似的过程, 受限网络的返回数据就会被主机接收到了.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;为什么选择shadowsocks&#34;&gt;为什么选择shadowsocks?&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;现在网上这么多vpn服务, 为什么要使用shadowsocks呢?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在一个能够使用的VPN也比较难找, 毕竟因为众所周知的原因, VPN很容易就被封. 就性价比来说, 买来的VPN也不如自己租的服务器.&lt;/p&gt;

&lt;p&gt;最关键的是, 用自己的能力科学上网是非常爽的.&lt;/p&gt;

&lt;h3 id=&#34;准备步骤&#34;&gt;准备步骤&lt;/h3&gt;

&lt;p&gt;现在知道原理了之后, 就明白实现shadowsocks有三个关键点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一台在防火墙之外的服务器&lt;/li&gt;
&lt;li&gt;本地安装的 shadowsocks 客户端, 用于加密以及传输数据&lt;/li&gt;
&lt;li&gt;安装在服务器的 shadowsocks 服务端, 用于解密以及数据的中转&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就像开头所说的, 这篇教程使用的是 &lt;strong&gt;Vultr&lt;/strong&gt; 的服务器, 最便宜的一种是&lt;em&gt;2.5美元/月&lt;/em&gt;, 500G流量/月, 实际上一般人连100G都用不到. Vultr 的服务器是按&lt;strong&gt;小时计费&lt;/strong&gt;的, 只要账户里有钱, 就会每小时自动扣除, &lt;strong&gt;即使关机也会计费&lt;/strong&gt;. 另外, Vultr 支持&lt;strong&gt;支付宝&lt;/strong&gt;（UPDATE 2019: 现在也支持微信了 ）.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;点击这个&lt;a href=&#34;https://www.vultr.com/&#34;&gt;Vultr链接&lt;/a&gt;注册帐号并部署服务器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对了, 本机的系统是 Windows/Mac/Linux 甚至手机都没关系。使用 SSH 连接服务器的话 Windows 推荐安装 &lt;a href=&#34;https://pc.qq.com/detail/4/detail_2644.html&#34;&gt;Xshell&lt;/a&gt;，Mac 和 Linux 上直接使用&lt;strong&gt;Terminal&lt;/strong&gt; 就可以了。&lt;/p&gt;

&lt;p&gt;好了, 这就开始吧!&lt;/p&gt;

&lt;h1 id=&#34;部署&#34;&gt;部署&lt;/h1&gt;

&lt;h2 id=&#34;vultr服务器部署&#34;&gt;Vultr服务器部署&lt;/h2&gt;

&lt;p&gt;注册完Vultr帐号了并且向账户内存入足够的钱后就可以开始服务器的部署了. 点击&lt;strong&gt;Deploy now&lt;/strong&gt;或者&lt;a href=&#34;https://my.vultr.com/deploy/&#34;&gt;部署服务器&lt;/a&gt;进入服务器部署页面. 一次对以下内容修改:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择服务器位置. 这里的位置可以随意, 速度差距不大, 不过建议&lt;strong&gt;不要选择日本&lt;/strong&gt;的服务器, 因为虽然日本的服务器速度最快, 但是ip常常被封, 需要经常换ip. 如果想要&lt;a href=&#34;https://www.vultrvps.com/test-server&#34;&gt;测试服务器速度&lt;/a&gt;的话可以从这个网站测试, 或者ping一下也可以.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择服务器系统. &lt;strong&gt;CentOS 6+，Debian 7+，Ubuntu 12+&lt;/strong&gt;都可以支持的, 这里建议选择 &lt;strong&gt;Ubuntu 18.04 64bits&lt;/strong&gt; 的版本, 因为这可以方便之后用&lt;strong&gt;锐速&lt;/strong&gt;或者 &lt;strong&gt;BBR&lt;/strong&gt; 加速.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/18/5b7829bc76e37.jpg&#34; alt=&#34;选择服务器系统&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;选择价位. 值得高兴的是最近(2018.8.19)Vultr推出了全部服务器&lt;strong&gt;$2.5/mo&lt;/strong&gt;的价位, 以前的话只有一些特定服务器才会有这价位, 所以机会难得. 这里选择随意, 虽然高价位提升了带宽和流量, 但说实话如果只是单人使用的话&lt;strong&gt;$2.5/mo&lt;/strong&gt;就足够了.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/18/5b782bcfe904a.jpg&#34; alt=&#34;优惠&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;额外选项. 这里选择第一个&lt;strong&gt;Enable IPv6&lt;/strong&gt;就可以了.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/18/5b782b53ca373.jpg&#34; alt=&#34;Vultr额外选项&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;其他选项保持默认, 点击右下&lt;strong&gt;Deploy Now&lt;/strong&gt;就开始自动部署了.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;新建的服务器需要几分钟的时间部署, 这段时间可以用来下载&lt;strong&gt;Xshell&lt;/strong&gt;(windows)或者吃瓜, 部署结束后在个人页面就可以看到&lt;strong&gt;Status&lt;/strong&gt;显示部署完成.&lt;/p&gt;

&lt;p&gt;点击新建的服务器, 在&lt;strong&gt;Overview&lt;/strong&gt;标签下可以看到&lt;strong&gt;IP Address&lt;/strong&gt;, &lt;strong&gt;Username&lt;/strong&gt;, 以及&lt;strong&gt;Password&lt;/strong&gt;,这三行就是之后连接服务器的关键.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/18/5b78320edfa18.png&#34; alt=&#34;Overview&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;服务端ss服务搭建&#34;&gt;服务端ss服务搭建&lt;/h2&gt;

&lt;h3 id=&#34;windows&#34;&gt;Windows&lt;/h3&gt;

&lt;h4 id=&#34;连接到服务器&#34;&gt;连接到服务器&lt;/h4&gt;

&lt;p&gt;首先需要安装有&lt;a href=&#34;https://pc.qq.com/detail/4/detail_2644.html&#34;&gt;Xshell&lt;/a&gt;, 可以通过链接或百度搜索下载.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开&lt;em&gt;File-New(Alt+N)&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/19/5b797bce861fc.jpg&#34; alt=&#34;Xshell新建服务器设置&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如图设置服务器的信息, &lt;strong&gt;Name&lt;/strong&gt;是服务器的名字, 可以随便填. &lt;strong&gt;Host&lt;/strong&gt;填写在Vultr注册的服务器的&lt;strong&gt;IP Address&lt;/strong&gt;, 其他选项保持默认就行.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/19/5b797cc506ef6.jpg&#34; alt=&#34;Xshell服务器IP&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;接着设置用户名和密码, 用户名和密码分别是在 Vultr 上的 &lt;strong&gt;Username&lt;/strong&gt; 和 &lt;strong&gt;Password&lt;/strong&gt;, 填写完后勾上记住用户和密码就行了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果如下图所示, 则表明已经连接成功了. 注意连接的服务器必须是已经部署好的. 如果没有连接成功的话就多试几次, 还不行的话就ping一下ip, 看一下是不是被墙了. 如果ping不上的话就重新再部署一个服务器吧.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/19/5b79819f3cb5c.jpg&#34; alt=&#34;Xshell连接成功&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;搭建ss服务&#34;&gt;搭建ss服务&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载一键搭建ss服务脚本, 直接复制粘贴就行了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/flyzy2005/ss-fly
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行搭建ss代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ss-fly/ss-fly.sh -i yourpassword 1024
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里把&lt;strong&gt;yourpassword&lt;/strong&gt;替换为你想要设置的密码就行了, 随意设定, 以后使用ss客户端就用这个密码. 后面的&lt;strong&gt;1024&lt;/strong&gt;是服务的端口号, 默认是1024.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;等待一会后出现成功提示就可以了.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动服务:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/init.d/ss-fly start
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他相关操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;   启动：/etc/init.d/ss-fly start
   停止：/etc/init.d/ss-fly stop
   重启：/etc/init.d/ss-fly restart
   状态：/etc/init.d/ss-fly status
    
   修改配置文件：vim /etc/shadowsocks.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ss服务启动之后一般情况下不需要调整服务端了, 服务器常开就行.&lt;/p&gt;

&lt;h4 id=&#34;ss客户端&#34;&gt;ss客户端&lt;/h4&gt;

&lt;p&gt;shadowsocks的官方client地址是&lt;a href=&#34;https://shadowsocks.org/en/download/clients.html&#34;&gt;shadowsocks clients&lt;/a&gt;, 但似乎是被墙了. windows的GUI Client可以从Github上下载.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;shadowsocks-win&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/shadowsocks/shadowsocks-windows/releases&#34;&gt;shadowsocks-Qt5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载后解压启动shadowsocks, 会在右下角显示一个&lt;img src=&#34;https://i.loli.net/2018/08/19/5b7989881e4b4.jpg&#34; alt=&#34;&#34; /&gt;的图标,右击即可打开选项.  服务器添加窗口打开后填写服务器相关数据即可.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/08/19/5b798aa7c597f.jpg&#34; alt=&#34;客户端设置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;服务器添加成功后, 右键图标选择启动服务即可启动shadowsocks, 其他选项例如开机自启动,自动更新之类的看自己需求.&lt;/p&gt;

&lt;h1 id=&#34;参考文章&#34;&gt;参考文章&lt;/h1&gt;

&lt;p&gt;[&lt;a href=&#34;https://www.flyzy2005.win/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/&#34;&gt;一键脚本搭建SS/搭建SSR服务并开启BBR加速 | flyzy小站&lt;/a&gt;]&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Python文件打包与包内数据读写</title>
      <link>https://www.yucklys.com/post/python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/</guid>
      
        <description>&lt;p&gt;​   Python 写起来是很方便，不过需要发布的时候却总是有很多的麻烦事。&lt;/p&gt;

&lt;h2 id=&#34;添加数据文件到包内&#34;&gt;添加数据文件到包内&lt;/h2&gt;

&lt;h3 id=&#34;项目结构&#34;&gt;项目结构&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;在开始制作分发包之前，需要先对文件结构有一个清晰的认识，这里我用一个&lt;code&gt;funny_joke&lt;/code&gt;的示例来说明一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;E:.
│  MANIFEST.in
│  setup.py
│  
└─funny
    │  main.py
    │  __init__.py
    │  
    └─data
            funny_joke.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个项目的树状图如上所示，我们的主程序放在了&lt;code&gt;funny\main.py&lt;/code&gt;内，而我们需要从&lt;code&gt;funny\data&lt;/code&gt;中导入数据文件&lt;code&gt;funny_joke.txt&lt;/code&gt;。在打包的时候我们也希望能够&lt;strong&gt;保持&lt;/strong&gt;这个结构，也就是说在.egg包内数据文件的路径也是&lt;code&gt;funny\data\funny_joke.txt&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;manifest-in&#34;&gt;MANIFEST.in&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;MANIFEST.in&lt;/code&gt;文件包含Python在打包时读取的需要打包的附属文件的相对路径，当没有&lt;code&gt;MANIFEST.in&lt;/code&gt;时，Python会依据&lt;code&gt;setup.py&lt;/code&gt;中给出的打包文件进行打包，这种方法暂且不提。&lt;/p&gt;

&lt;p&gt;根据文件结构，我们需要的文件在&lt;code&gt;funny\data&lt;/code&gt;中。在&lt;code&gt;MANIFEST.in&lt;/code&gt;中，用&lt;code&gt;include&lt;/code&gt;表明需要打包的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;include funny\data\*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;表示导入所有文件，在文件路径和文件名之间有空格。&lt;/p&gt;

&lt;h3 id=&#34;setup-py&#34;&gt;setup.py&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;setup.py&lt;/code&gt;中只需要一行&lt;code&gt;include_package_data=True&lt;/code&gt;就可以了，完整的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from setuptools import setup, find_packages

setup(
    name=&#39;Tell a Joke&#39;,
    version=&#39;1.0.0&#39;,
    packages=find_packages(),
    include_package_data=True,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;setup&lt;/code&gt;函数还有很多其他的设置，可以&lt;a href=&#34;https://docs.python.org/3.7/distutils/setupscript.html&#34;&gt;查看文档&lt;/a&gt;了解更多的配置，这里就不赘述了。&lt;/p&gt;

&lt;h2 id=&#34;读取包内文件&#34;&gt;读取包内文件&lt;/h2&gt;

&lt;p&gt;由于安装包时文件位置的不确定，所以需要先获得当前文件的路径，再进行文件的读写。获取当前路径的方式有两种，一是通过&lt;code&gt;__file__&lt;/code&gt;获取，二是通过&lt;code&gt;import pkg_resources&lt;/code&gt;获取。&lt;/p&gt;

&lt;h3 id=&#34;file&#34;&gt;__file__&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
this_dir, this_filename = os.path.split(__file__)
DATA_PATH = os.path.join(this_dir, &amp;quot;data&amp;quot;, &amp;quot;funny_joke.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;os.path.spilt(__file__)&lt;/code&gt;函数可以获得该文件的文件名和文件路径，这里我们不需要文件名，所以只关注文件路径就行了。获取了文件路径之后，通过&lt;code&gt;os.path.join(this_dir, &amp;quot;path_to_the_file&amp;quot;)&lt;/code&gt;取得数据文件的路径，其中&lt;code&gt;this_dir&lt;/code&gt;表示的是当前运行的py文件的路径，后面的&lt;code&gt;&amp;quot;path_to_the_file&amp;quot;&lt;/code&gt;是&lt;strong&gt;数据文件相对于主程序的相对路径&lt;/strong&gt;。对于示例的情况来说，代码如上。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个方法仅适用于数据文件的路径可以被表示的情况，在分发包（如egg）里的数据文件就无法通过这样的方式读取，其次&lt;code&gt;py2exe&lt;/code&gt;打包的文件也无法读取，因为数据文件是以zip形式储存的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;pkg-resources&#34;&gt;pkg_resources&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pkg_resources
DATA_PATH = pkg_resources.resource_filename(&#39;funny.main&#39;, &#39;data/funny_joke.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pke_resources.resource_filename(package_or_requirement, resource_name)&lt;/code&gt;中，&lt;code&gt;package_or_requirement&lt;/code&gt;填写的是库的名称，即&lt;code&gt;funny.main&lt;/code&gt;。&lt;code&gt;resource_name&lt;/code&gt;处填写数据文件相对于库文件所在路径的相对路径。&lt;/p&gt;

&lt;p&gt;当然，&lt;code&gt;package_or_requirement&lt;/code&gt;处填&lt;code&gt;funny&lt;/code&gt;和&lt;code&gt;funny.main&lt;/code&gt;都是一样的效果，&lt;code&gt;funny&lt;/code&gt;指向的是&lt;code&gt;funny\__init__.py&lt;/code&gt;，而&lt;code&gt;funny.main&lt;/code&gt;指向的是&lt;code&gt;funny\main.py&lt;/code&gt;，实际上都在同一个文件夹，所以对后面的&lt;code&gt;resource_name&lt;/code&gt;没有影响。如果你的项目比较复杂，需要根据&lt;code&gt;package_or_requirement&lt;/code&gt;填写的文件路径补充相应的相对路径。&lt;/p&gt;

&lt;p&gt;看起来很复杂？&lt;strong&gt;实际上并不是!&lt;/strong&gt;&lt;code&gt;pkg_resources.resource_filename()&lt;/code&gt;函数的处理方式只要理解了，就能很轻易地掌握这个方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先在包中寻找&lt;code&gt;funny\main.py&lt;/code&gt;所在的文件夹。如果这个文件包含在文件夹内，那么就直接获得路径；如果这个文件被压缩成egg，那么它会解压egg文件到&lt;code&gt;...\Python-Eggs\Cache&lt;/code&gt;内。这里我们的文件包含在egg文件里。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:.
└─Cache
   └─tell_a_joke-1.0.0-py3.5.egg-tmp
       └─funny
# 先获得了这样的一个直达funny的路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后它将&lt;code&gt;resource_name&lt;/code&gt;，也就是数据文件&lt;strong&gt;关于&lt;code&gt;funny&lt;/code&gt;的相对路径&lt;/strong&gt;，代入到1中得到的文件夹中，如果能够找到文件（或文件夹）的话，就返回整个路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;C:.
└─Cache
   └─tell_a_joke-1.0.0-py3.5.egg-tmp
       └─funny
           └─data
                   funny_joke.txt
# 然后查找.\data\funny_joke.txt是否存在，存在则获得其路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;对比&#34;&gt;对比&lt;/h3&gt;

&lt;p&gt;这两种方法各有优劣，&lt;code&gt;__file__&lt;/code&gt;无法从egg或zip中获得路径，而&lt;code&gt;pkg_resources&lt;/code&gt;虽然能够从egg中获取文件路径，但是当对文件进行更改的时候，只会对复制在&lt;code&gt;Cache&lt;/code&gt;下的数据文件进行更改，而egg中的源文件不变。如果不小心清理了临时文件，更改过的数据文件就没了。所以说除非是&lt;strong&gt;特别小&lt;/strong&gt;的数据量，或者是&lt;strong&gt;对数据写入没要求&lt;/strong&gt;的程序，最好还是放在文件夹内，方便保存。&lt;/p&gt;

&lt;p&gt;最后以一张对比表格结束战斗。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;__file__&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;pkg_resources&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;适用范围&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;文件夹内&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;文件夹内，压缩包内&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;方便程度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;写起来不是那么费劲，不用写绝对路径&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;实际上获得的是一个绝对路径&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;文件读写&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;读，写（仅限文件夹）&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;读（全方位），写(仅限文件夹）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
      
    </item>
    
    <item>
      <title>Windows 10 更换第三方主题</title>
      <link>https://www.yucklys.com/post/win10-ultrauxthemepatcher/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/win10-ultrauxthemepatcher/</guid>
      
        <description>&lt;p&gt;​   Windows 10 系统在主题的定制功能上做了削减，导致主题只能做到更改窗口颜色等有限的改变。不过通过 UXThemePather 可以让我们在 Windows 10 上使用第三方主题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.yucklys.com/images/1531654651295.png&#34; alt=&#34;Win10主题&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用uxthemepatcher破解&#34;&gt;使用UXThemePatcher破解&lt;/h2&gt;

&lt;h3 id=&#34;破解前的准备&#34;&gt;破解前的准备&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;所有的破解都是有风险的, 为了防止万恶的黑屏出现, 在开始破解前建议手动建立一个&lt;strong&gt;系统还原点&lt;/strong&gt;:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;打开win10自带的&lt;strong&gt;设置&lt;/strong&gt;, 搜索&lt;code&gt;创建还原点&lt;/code&gt;就会弹出一个窗口. 一般还原点都是设置在C盘的, 选择C盘后查看后面「保护」一项是否为「启用」，如果是就直接进入第三步，反之则看下一步。&lt;/li&gt;
&lt;li&gt;确保选中C盘，点击「配置」，磁盘空间使用量的滑条随意，但建议1GB左右就足够了，如果以后打算长期开启这个功能的话可以调高，不过我们只是启用一次，之后就会清除还原点，毕竟系统盘空间宝贵. 之后选择「启用系统保护」就ok了。&lt;/li&gt;
&lt;li&gt;确保选中C盘，点击「创建」，系统会自动创建一个还原点，稍等片刻直到弹出提示说明创建完成就可以了。在这段等待时间里可以先去下载我们要用的&lt;a href=&#34;https://www.syssel.net/hoefs/software_uxtheme.php?lang=en&#34;&gt;UXThemePatcher&lt;/a&gt;软件&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ultrauxthemepatcher&#34;&gt;UltraUXThemePatcher&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;软件下载完成后是一个.exe文件，确保前期准备都做好了之后双击运行。安装过程很简单，一路回车就可以了。然后立即重启。&lt;/li&gt;
&lt;li&gt;重启完成后，再运行一遍安装程序，其中有三项需要破解的内容，如果后面的「status」为「patched」话，就说明已经破解完成了，反之就再运行一遍，直到全部破解完毕。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;主题的安装&#34;&gt;主题的安装&lt;/h2&gt;

&lt;p&gt;​   如果你一直到现在系统还依然在正常的运行的话，那恭喜你，你可以随意安装&lt;strong&gt;对应版本&lt;/strong&gt;的第三方主题了。鉴于大部分人还是翻不了墙，这里提供一个国内的&lt;a href=&#34;http://zhutix.com/pc/&#34;&gt;主题网址。&lt;/a&gt;找到喜欢的主题后只需下载并解压，然后运行.exe文件，一路默认设置安装，完成后即可在&lt;strong&gt;设置－个性化－主题&lt;/strong&gt;里找到刚安装的主题了。&lt;/p&gt;

&lt;p&gt;​   另外对于一些主题的特殊排版需要下载一些辅助软件，可以从&lt;a href=&#34;http://zhutix.com/tools/&#34;&gt;这里&lt;/a&gt;下载，一般来说&lt;a href=&#34;http://zhutix.com/tools/oldnewexplorer/&#34;&gt;OldNewexplorer&lt;/a&gt;是必备的，按照内部的教程安装就行。当然不是所有的主题都是完美无暇的，总有几个主题在自己的系统中表现不佳，这种情况也是在所难免，花点时间挑选一个在外观和细节上都很令你满意的主题就行了。&lt;/p&gt;

&lt;p&gt;​   最后晒一晒我的桌面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/11/06/5be12fdadaa51.png&#34; alt=&#34;我的桌面Windows&#34; /&gt;我的桌面使用的软件：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Rainmeter&lt;/li&gt;
&lt;li&gt;Wallpaper Engine&lt;/li&gt;
&lt;li&gt;Rocket Dock&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;​   最后的最后，windows虽然看上去没有mac或者linux那么高端，但是经过调教后的windows也是拥有不输于另外两者的颜值的。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Hexo &#43; github 搭建自己的个人博客</title>
      <link>https://www.yucklys.com/post/hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;p&gt;​   最近想搭一个个人博客，搜了一下之后找到了 Hexo 这个工具，正好借着 GitHub Pages 这个平台搭一个看看效果。&lt;/p&gt;

&lt;p&gt;​   个人博客应该是什么样子的？这一点估计每个人都有自己的想法。这里仅提供一些参考，个人博客还是需要自己去折腾为好。&lt;/p&gt;

&lt;p&gt;​   经过小半天的折腾, 最终成品就是大家现在正在看着的博客了, 总共耗时1小时. 现在博客具备的功能如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个优秀的界面(by next)&lt;/li&gt;
&lt;li&gt;评论功能(by Valine)&lt;/li&gt;
&lt;li&gt;我的联系方式&lt;/li&gt;
&lt;li&gt;本地搜索系统(hexo-generator-search)&lt;/li&gt;
&lt;li&gt;标签及分类&lt;/li&gt;
&lt;li&gt;评论人数统计(leancloud)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;

&lt;h3 id=&#34;开始&#34;&gt;开始&lt;/h3&gt;

&lt;p&gt;​   首先在&lt;a href=&#34;https://github.com/&#34;&gt;github&lt;/a&gt;上需要一个自己的项目库, 如果没有帐号的需要自己先注册一个. 新建一个repository, 项目名为&lt;code&gt;whatever.github.io&lt;/code&gt;, 选择生成默认README.md. 这样一个保存博客文件的项目库就做好了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/05/5c30424ba3950.png&#34; alt=&#34;新建Repo&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;hexo&#34;&gt;hexo&lt;/h3&gt;

&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;

&lt;p&gt;​   hexo安装前置要求是&lt;a href=&#34;http://nodejs.org/&#34;&gt;Node.js&lt;/a&gt;和&lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt;, 需要先安装这两个才能安装hexo. 检测是否安装可以打开终端, 输入&lt;code&gt;node -v&lt;/code&gt;和&lt;code&gt;git --version&lt;/code&gt;, 如果没有报错则可以安装hexo了. 在终端输入&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;即可安装hexo, 输入&lt;code&gt;hexo -v&lt;/code&gt;检测是否安装成功, 没有报错就可以开始初始化了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/01/05/5c30424b85682.png&#34; alt=&#34;检查安装&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;初始化&#34;&gt;初始化&lt;/h4&gt;

&lt;p&gt;​   在任意位置新建一个文件夹用来存放博客文件, 然后在终端界面打开文件夹, 输入&lt;code&gt;hexo init&lt;/code&gt;即可完成初始化 , 当看到&lt;code&gt;INFO  Start blogging with Hexo!&lt;/code&gt;时表明初始化完成, 此时的项目结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── _config.yml #项目配置文件
├── package.json
├── node_modules
├── package-lock.json
├── scaffolds
├── source
|   └── _posts #文章存放
└── themes #存放主题
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   运行&lt;code&gt;npm install&lt;/code&gt;安装依赖, 然后就可以开始配置了.&lt;/p&gt;

&lt;h4 id=&#34;配置&#34;&gt;配置&lt;/h4&gt;

&lt;p&gt;​   项目的配置在_config.yml中进行, 用任意文本编辑器打开后, 需要自己根据自己的情况更新以下版块(每一部分可以通过搜索找到):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;site&lt;/li&gt;
&lt;li&gt;URL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;url&lt;/code&gt;填写自己在github上新建的库名的github pages网址就行了(&lt;a href=&#34;https://yourrepository&#34;&gt;https://yourrepository&lt;/a&gt;), 比如我的就是(&lt;a href=&#34;https://yucklys.github.io&#34;&gt;https://yucklys.github.io&lt;/a&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Deployment
&lt;code&gt;type&lt;/code&gt;填写git, 然后填写repository和branch如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;deploy:
type: git
repository: git@github.com:Yucklys/yucklys.github.io.git
branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   repository填写项目库SSH链接, 从项目库的clone or download选项中复制SSH链接然后粘贴, branch填写master.&lt;/p&gt;

&lt;h4 id=&#34;hello-world&#34;&gt;hello world&lt;/h4&gt;

&lt;p&gt;​   终端输入&lt;code&gt;hexo g&lt;/code&gt;生成页面, 结束后输入&lt;code&gt;hexo s&lt;/code&gt;在本地服务器上显示页面, 默认端口是4000, 显示&lt;code&gt;INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.&lt;/code&gt;时打开浏览器, 输入localhost:4000并跳转即可看到自己的博客页以及初始的一个文章.&lt;/p&gt;

&lt;h3 id=&#34;上传repository&#34;&gt;上传repository&lt;/h3&gt;

&lt;p&gt;​   首先全局声明自己身份, 在终端输入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;Your Name&amp;quot;
$ git config --global user.email &amp;quot;email@example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   在终端输入&lt;code&gt;cd ~/.ssh&lt;/code&gt;, 如果返回”… No such file or directory ”, 则直接输入&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;your_email@youremail.com&amp;quot;&lt;/code&gt;(&lt;strong&gt;邮箱换成你的邮箱&lt;/strong&gt;). 如果能进入ssh文件夹的话则输入&lt;code&gt;mkdir key_backup mv id_isa* key_backup&lt;/code&gt;备份, 然后再输入&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;your_email@youremail.com&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;​   可以一路回车, 如果想要每次输入密码的话, 也可以设置密码.&lt;/p&gt;

&lt;p&gt;​   然后依次输入以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-agent -s
ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   如果出错显示&lt;code&gt;Could not open a connection to your authentication agent&lt;/code&gt;, 就输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval `ssh-agent -s`
ssh-add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   之后输入&lt;code&gt;clip &amp;lt; ~/.ssh/id_rsa.pub&lt;/code&gt;复制ssh key到剪切板. 在github用户设置界面可以看到&lt;strong&gt;SSH and GPG keys&lt;/strong&gt;选项, 在该项下选择New SSH key, 随便写个名字, 然后将key粘贴到key中并保存. 之后在终端中输入&lt;code&gt;ssh -T git@github.com&lt;/code&gt;查看是否成功添加, 有警告就一路yes, 出现&lt;code&gt;Hi username! You&#39;ve successfully authenticated, but Github does not provide shell access&lt;/code&gt;说明添加成功.&lt;/p&gt;

&lt;h4 id=&#34;部署&#34;&gt;部署&lt;/h4&gt;

&lt;p&gt;​   终端切换到博客文件夹, 输入&lt;code&gt;hexo d&lt;/code&gt;部署, 显示&lt;code&gt;INFO  Deploy done: git&lt;/code&gt;表明部署完成. 在浏览器中输入yucklys.github.io即可进入到博客界面了.&lt;/p&gt;

&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;

&lt;p&gt;​   hexo的next主题最大的优点就是它的用户广泛, 所以大部分的功能都可以在&lt;code&gt;主题配置文件&lt;/code&gt;中找到, 包含有完整的帮助文件以及众多next主题的大神用户自定义的方案, 可以说只需要&lt;del&gt;cv&lt;/del&gt;简单模仿就可以做出一个不错的博客页. 当然写作的质量还是很关键的, 会用markdown是必不可少的一项技能, 这里可以去看一下hexo的&lt;a href=&#34;https://hexo.io/zh-cn/docs/writing.html&#34;&gt;官方写作教程&lt;/a&gt;, markdown的教程网上有许多, 善用google或百度.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;em&gt;2018.11.4更新&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;现在使用的是&lt;a href=&#34;https://github.com/ppoffice/hexo-theme-icarus&#34;&gt;icarus&lt;/a&gt;主题，换主题有两方面原因，一是&lt;strong&gt;icarus&lt;/strong&gt;的确是一款很优秀的主题，二是&lt;strong&gt;next&lt;/strong&gt;用的人实在是太多了，每次看别人的博客都有种撞衫的不爽感……&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>测试</title>
      <link>https://www.yucklys.com/post/%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.yucklys.com/post/%E6%B5%8B%E8%AF%95/</guid>
      
        <description>&lt;p&gt;测试一下使用 ox-hugo 写博客&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
