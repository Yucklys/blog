<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>「逐渐」</title>
  
  <subtitle>Yucklys</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yucklys.com/"/>
  <updated>2019-01-18T12:08:19.597Z</updated>
  <id>http://www.yucklys.com/</id>
  
  <author>
    <name>Yucklys</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Electron组件在React中的引用问题</title>
    <link href="http://www.yucklys.com/2018/12/16/Electron%E4%B8%8EReact%E7%BB%93%E5%90%88/"/>
    <id>http://www.yucklys.com/2018/12/16/Electron与React结合/</id>
    <published>2018-12-16T11:12:46.000Z</published>
    <updated>2019-01-18T12:08:19.597Z</updated>
    
    <content type="html"><![CDATA[<p>虽然说Electron官方使用的是最基本的html + css的方法展示的各种API，但是作为9102年的前端程序猿，使用Electron这样的框架当然是要搭配着三大框架来用啊。但是如果使用require直接在React中引用Electron的话，会报错<code>TypeError: fs.existsSync is not a function</code>。这里就讲一下我搜集的几种解决方法，能够在React中直接引用Electron。<br><a id="more"></a></p><h2 id="Webpack-target属性"><a href="#Webpack-target属性" class="headerlink" title="Webpack target属性"></a>Webpack target属性</h2><p>首先这个问题早已有人想到了，webpack的<code>target: electron-renderer</code>属性就是为此而来的。这里展示的是改造<code>create-react-app</code>的方法，其他脚手架诸如此类。</p><p>项目新建好后，首先一发<code>yarn eject</code>展开所有配置，在多出来的config文件夹下就有我们需要更改的<code>webpack.config.js</code>文件。<code>create-react-app</code>在基础的webpack配置上添加了很多内容，比如说环境检测以及sass，不过我们这里直接在return里添加target属性，如果想要根据develop或product环境切换target的话可以自行添加。</p><figure class="highlight javascript hljs"><figcaption><span>config/webpack.config.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// other configs...</span></span><br><span class="line"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">webpackEnv</span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">// some configs</span></span><br><span class="line">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        target: <span class="hljs-string">'electron-renderer'</span>, <span class="hljs-comment">// 添加target</span></span><br><span class="line">        <span class="hljs-comment">// other configs</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，现在我们再运行<code>yarn start</code>的话，会发现通过浏览器无法打开<code>localhost:3000</code>了。接下来在根目录新建Electron主程序入口<code>main.js</code>。</p><figure class="highlight javascript hljs"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 保持对window对象的全局引用，如果不这么做的话，当JavaScript对象被</span></span><br><span class="line"><span class="hljs-comment">// 垃圾回收的时候，window对象将会自动的关闭</span></span><br><span class="line"><span class="hljs-keyword">let</span> win;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 创建浏览器窗口。</span></span><br><span class="line">win = <span class="hljs-keyword">new</span> BrowserWindow(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">600</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 然后加载应用的 index.html。</span></span><br><span class="line"><span class="hljs-comment">// win.loadFile('index.html');</span></span><br><span class="line"><span class="hljs-comment">// 这里没有选择官方的从文件加载的方法，而是选择从localhost加载</span></span><br><span class="line">win.loadURL(<span class="hljs-string">'http://localhost:3000'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 打开开发者工具</span></span><br><span class="line">win.webContents.openDevTools();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 当 window 被关闭，这个事件会被触发。</span></span><br><span class="line">win.on(<span class="hljs-string">'closed'</span>, () =&gt; &#123;</span><br><span class="line"><span class="hljs-comment">// 取消引用 window 对象，如果你的应用支持多窗口的话，</span></span><br><span class="line"><span class="hljs-comment">// 通常会把多个 window 对象存放在一个数组里面，</span></span><br><span class="line"><span class="hljs-comment">// 与此同时，你应该删除相应的元素。</span></span><br><span class="line">win = <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Electron 会在初始化后并准备</span></span><br><span class="line"><span class="hljs-comment">// 创建浏览器窗口时，调用这个函数。</span></span><br><span class="line"><span class="hljs-comment">// 部分 API 在 ready 事件触发后才能使用。</span></span><br><span class="line">app.on(<span class="hljs-string">'ready'</span>, createWindow);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 当全部窗口关闭时退出。</span></span><br><span class="line">app.on(<span class="hljs-string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line"><span class="hljs-comment">// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span></span><br><span class="line"><span class="hljs-comment">// 否则绝大部分应用及其菜单栏会保持激活。</span></span><br><span class="line"><span class="hljs-keyword">if</span> (process.platform !== <span class="hljs-string">'darwin'</span>) &#123;</span><br><span class="line">app.quit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(<span class="hljs-string">'activate'</span>, () =&gt; &#123;</span><br><span class="line"><span class="hljs-comment">// 在macOS上，当单击dock图标并且没有其他窗口打开时，</span></span><br><span class="line"><span class="hljs-comment">// 通常在应用程序中重新创建一个窗口。</span></span><br><span class="line"><span class="hljs-keyword">if</span> (win === <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">createWindow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 在这个文件中，你可以续写应用剩下主进程代码。</span></span><br><span class="line"><span class="hljs-comment">// 也可以拆分成几个文件，然后用 require 导入。</span></span><br></pre></td></tr></table></figure><p>同时更改<code>package.json</code>，加入<code>main: &quot;main.js&quot;</code>，<code>homepage: &quot;./&quot;</code>，同时在scripts中添加<code>&quot;electron&quot;: &quot;electron .&quot;</code>，不要忘记<code>yarn add electron</code>。</p><p>准备工作完成之后，可以写一个小例子来测试一下渲染进程以及主进程的通信。</p><figure class="highlight javascript hljs"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// 在这个文件中，你可以续写应用剩下主进程代码。</span></span><br><span class="line"><span class="hljs-comment">// 也可以拆分成几个文件，然后用 require 导入。</span></span><br><span class="line"><span class="hljs-keyword">const</span> &#123; ipcMain &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>);</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="hljs-string">'react-test'</span>, (event, arg) =&gt; &#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`get <span class="hljs-subst">$&#123;arg&#125;</span> from Renderer process.`</span>);</span><br><span class="line">event.sender.send(<span class="hljs-string">'main-process-reply'</span>, <span class="hljs-string">'world'</span>);</span><br><span class="line">&#125;); <span class="hljs-comment">// 接收到react-test信号后返回main-process-reply并打印'get $&#123;arg&#125; from Renderer process'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript hljs"><figcaption><span>src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        ipcRenderer.send(<span class="hljs-string">'react-test'</span>, <span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// 发送react-test信号，同时arg为'Hello'</span></span><br><span class="line"></span><br><span class="line">        ipcRenderer.on(<span class="hljs-string">'main-process-reply'</span>, (_event, arg) =&gt; &#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">        &#125;); <span class="hljs-comment">// 接收main-process-reply并打印arg</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来依次运行<code>yarn start</code>以及<code>yarn electron</code>，在终端以及electron应用的控制台应该都可以看到打印出的信息，通信成功！</p><h2 id="Preload提前引入electron"><a href="#Preload提前引入electron" class="headerlink" title="Preload提前引入electron"></a>Preload提前引入electron</h2><p>利用webpack的target属性确实是最稳妥，最官方的解决方案了，但是对于一些高度封装webpack并且没有eject选项的脚手架来说，就无法通过target属性来简单解决了。这里使用的是<code>dva new --demo</code>新建的一个项目，我们会在主进程中提前引入我们需要的包以达到在渲染进程中使用的目的。</p><p>首先开始的步骤同上，安装electron并且新建main.js，在主进程文件main.js中写入我们之前用过的测试例子，同时做一些修改。</p><figure class="highlight javascript hljs"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWindow</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  win = <span class="hljs-keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="hljs-number">800</span>,</span><br><span class="line">    height: <span class="hljs-number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      preload: __dirname + <span class="hljs-string">'/preload.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  win.loadURL(<span class="hljs-string">'http://localhost:8000'</span>); <span class="hljs-comment">// Roadhog默认的localhost端口为8000</span></span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在preload选项中引用了根目录下在preload.js文件，在该文件中写入：</p><figure class="highlight javascript hljs"><figcaption><span>preload.js</span></figcaption><table><tr><td class="code"><pre><span class="line">global.electron = <span class="hljs-built_in">require</span>(<span class="hljs-string">'electron'</span>);</span><br></pre></td></tr></table></figure><p>OK，现在我们修改<code>src/index.js</code>文件，就可以实现进程间通讯了。</p><figure class="highlight javascript hljs"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line"><span class="hljs-comment">// 3. Router</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-built_in">window</span>.electron;</span><br><span class="line">    ipcRenderer.send(<span class="hljs-string">'react-test'</span>, <span class="hljs-string">'Hello'</span>);</span><br><span class="line">    ipcRenderer.on(<span class="hljs-string">'main-process-reply'</span>, (_event, arg) =&gt; &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;arg&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;div&gt;Hello, world!&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// ...</span></span><br></pre></td></tr></table></figure><p>通过这种方式，在浏览器中打开的话会报错，无法引用ipcRenderer，但是如果通过electron打开的话就可以正常地进行通讯了。而且通过<code>preload: &#39;file&#39;</code>这种方式，我们还可以很方便地把一些设置全局共享，比如：</p><figure class="highlight javascript hljs"><figcaption><span>preload.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);</span><br><span class="line"></span><br><span class="line">global.path = path.join(os.homedir(), <span class="hljs-string">'.config'</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除开这两种自己动手的方法以外，在GitHub上还有各种xxx-electron-boilerplate可供使用，不过有些年代比较久远，并且年久失修，issue没人处理，很多依赖都落后几个版本了，反而不是很好用。当然，<a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate" target="_blank" rel="noopener">electron-react-boilerplate</a>这个1w star项目现在还是很活跃的，比起自己这样凑活着搭起来的框架更成体系。具体是怎么样的结合就看自己项目的需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然说Electron官方使用的是最基本的html + css的方法展示的各种API，但是作为9102年的前端程序猿，使用Electron这样的框架当然是要搭配着三大框架来用啊。但是如果使用require直接在React中引用Electron的话，会报错&lt;code&gt;TypeError: fs.existsSync is not a function&lt;/code&gt;。这里就讲一下我搜集的几种解决方法，能够在React中直接引用Electron。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end" scheme="http://www.yucklys.com/categories/Front-end/"/>
    
    
      <category term="React" scheme="http://www.yucklys.com/tags/React/"/>
    
      <category term="Electron" scheme="http://www.yucklys.com/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>React滚动事件监听</title>
    <link href="http://www.yucklys.com/2018/11/19/react-scroll/"/>
    <id>http://www.yucklys.com/2018/11/19/react-scroll/</id>
    <published>2018-11-19T03:55:12.000Z</published>
    <updated>2019-01-18T12:03:34.207Z</updated>
    
    <content type="html"><![CDATA[<p>对于多页面的网站来说，一个导航栏是必不可少的。现在常用的一些64px高度的导航栏占用的空间对于一些展示型网站来说就有点过于大了。为了能够节省下这部分空间益达到完美的图像展示空间，我们需要在适当的时候隐藏导航栏。</p><p><img src="https://i.loli.net/2018/11/22/5bf6ab0d794ca.gif" alt="向下滚动隐藏header"></p><a id="more"></a><h2 id="自动隐藏Header"><a href="#自动隐藏Header" class="headerlink" title="自动隐藏Header"></a>自动隐藏Header</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先还是以<code>create-react-app</code>作为框架，在终端下输入<code>create-react-app react-scroll</code>创建项目文件夹，创建完成后进入文件夹输入<code>npm start</code>，如果顺利的话此时已经可以在<code>localhost:3000</code>看见初始的应用界面了。</p><p>首先先改一下源文件，修改header并且加上一个足够长的内容(2000px)，让页面可以滚动足够的距离。这里为了节约篇幅，只放上需要改动的部分。</p><figure class="highlight javascript hljs"><figcaption><span>src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-comment">//......</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="hljs-string">"App"</span>&gt;</span><br><span class="line">        &lt;header className=<span class="hljs-string">"App-header"</span>&gt;</span><br><span class="line">          Header1</span><br><span class="line">        &lt;<span class="hljs-regexp">/header&gt;</span></span><br><span class="line"><span class="hljs-regexp">        &lt;div className="App-container" /</span>&gt;</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp">/</span><span class="hljs-regexp">/......</span></span><br></pre></td></tr></table></figure><p>对应的css文件也需要改一下，同上，这里的代码只是需要改动的部分，未在这里贴出的代码不需要调整。</p><figure class="highlight css hljs"><figcaption><span>src/App.css</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-selector-class">.App-header</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">position</span>: fixed; <span class="hljs-comment">/*固定header*/</span></span><br><span class="line">  <span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;</span><br><span class="line">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">64px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.App-container</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">70px</span>;</span><br><span class="line">  <span class="hljs-attribute">width</span>: auto;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">2000px</span>;</span><br><span class="line">  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="line">  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(126, 248, 238, 0.856);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的页面应该是这个样子，现在我们可以进行下一步的修改，让header能随着我们的滚动而消失或浮现。<img src="https://i.loli.net/2018/11/19/5bf2b0528ee57.gif" alt="初始化"></p><h3 id="添加滚动事件监听及判断"><a href="#添加滚动事件监听及判断" class="headerlink" title="添加滚动事件监听及判断"></a>添加滚动事件监听及判断</h3><h4 id="滚动事件监听"><a href="#滚动事件监听" class="headerlink" title="滚动事件监听"></a>滚动事件监听</h4><p>现在我们需要加入对滚动事件的监控来获取滚动数据。在这个例子里使用的是<code>window.addEventLister(&#39;scroll&#39;, function() {})</code>方法，这个方法接受两个参数，<code>event</code>和<code>function</code>，针对我们这个例子的话分别是<code>scroll</code>事件并且绑定为<code>handleScroll</code>函数。</p><figure class="highlight javascript hljs"><figcaption><span>/src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="hljs-built_in">window</span>.addEventLister(<span class="hljs-string">'scroll'</span>, handleScroll);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleScroll() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scroll'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/22/5bf622abc976d.gif" alt="滚动初体验"></p><h4 id="滚动事件判断"><a href="#滚动事件判断" class="headerlink" title="滚动事件判断"></a>滚动事件判断</h4><p>现在知道了我们的页面什么时候滚动，那怎么判断我们滚动的方向呢？当添加<code>window.addEventListener</code>并把<code>scroll</code>事件绑定到<code>handleScroll</code>之后，就可以通过<code>window.scrollY</code>获取现在滚动的位置距离<strong>页面顶部</strong>有多远<a href="当然与之相对还有`window.scrollX`，监控现在滚动位置距离页面左侧有多远。">^1</a>。</p><figure class="highlight javascript hljs"><figcaption><span>src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">    handleScroll() &#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.scrollY)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/22/5bf625cf80f86.gif" alt="Y轴座标"></p><p>那如何通过这个参数判断滚动方向呢？假设说我们有一个<code>prevScroll</code>的变量，保存着我们之前页面所在的Y轴座标，那么我们通过<code>window.scrollY - prevScroll</code>就可以判断滚动方向了。如果这个数值为正，则为向下滚动；如果这个数值为负，则为向上滚动。</p><p><img src="https://i.loli.net/2018/11/22/5bf6295d240f0.png" alt="滚动判断"></p><p>如果对React足够熟悉的话应该立马就想到了<code>this.state</code>。现在我们创建一个<code>this.state.prevScroll</code>用来储存上一次的页面滚动位置，然后在每一次<code>handleScroll</code>进行完判断之后更新<code>this.state.prevScroll</code>。</p><figure class="highlight javascript hljs"><figcaption><span>src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(props);</span><br><span class="line">        <span class="hljs-keyword">this</span>.state = &#123;</span><br><span class="line">            prevScroll: <span class="hljs-number">0</span> <span class="hljs-comment">//初始化prevScroll</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">    <span class="hljs-comment">//滚动判断</span></span><br><span class="line">    handleScroll() &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> &#123; prevScroll &#125; = <span class="hljs-keyword">this</span>.state;</span><br><span class="line">        <span class="hljs-keyword">const</span> changeY = <span class="hljs-built_in">window</span>.scrollY;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> (changeY &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scroll downward'</span>)</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'scroll upward'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">this</span>.setState(&#123; <span class="hljs-attr">prevScroll</span>: <span class="hljs-built_in">window</span>.scrollY &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/22/5bf63ee2a7bfa.gif" alt="滚动判断"></p><p>现在通过同样的原理，把header的style属性指定为<code>this.state.headerStyle</code>，在滚动判断中添加适当的内容，就可以实现根据页面滚动显示或隐藏元素了。</p><p><img src="https://i.loli.net/2018/11/22/5bf68cd4f4147.gif" alt="滚动显示/隐藏header"></p><h4 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h4><p>细心的人可能发现了，我们这个组件反复渲染了多次，如果在<code>render</code>函数下加入一个<code>console.log(&#39;render&#39;)</code>的话，就可以看到对于每一个scroll事件的变化，我们的组件都渲染了两次，而且同样是scroll downward，依然进行了渲染，这样子的话有可能对性能造成不必要的负担。所以这里加上<code>shouldComponentUpdate</code>函数来判断什么时候进行渲染。</p><figure class="highlight javascript hljs"><figcaption><span>src/App.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(props);</span><br><span class="line">        <span class="hljs-keyword">this</span>.state = &#123;</span><br><span class="line">            prevScroll: <span class="hljs-number">0</span>,</span><br><span class="line">            currentDirection: <span class="hljs-number">0</span>,</span><br><span class="line">            headerStyle: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (nextState.currentDirection !== <span class="hljs-keyword">this</span>.state.currentDirection)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">        <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'scroll'</span>, <span class="hljs-keyword">this</span>.handleScroll.bind(<span class="hljs-keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/22/5bf6ab0d794ca.gif" alt="优化滚动显示"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>当然，这里的demo只是一个最简单的版本，实际上在这个例子的基础上还可以添加更多的条件判断，并且<code>scroll</code>事件的函数也不止<code>scrollY</code>，善用这些事件监听可以让你的页面更加地灵活。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于多页面的网站来说，一个导航栏是必不可少的。现在常用的一些64px高度的导航栏占用的空间对于一些展示型网站来说就有点过于大了。为了能够节省下这部分空间益达到完美的图像展示空间，我们需要在适当的时候隐藏导航栏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/22/5bf6ab0d794ca.gif&quot; alt=&quot;向下滚动隐藏header&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end" scheme="http://www.yucklys.com/categories/Front-end/"/>
    
    
      <category term="React" scheme="http://www.yucklys.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>搬家！GitHub-Page关联域名</title>
    <link href="http://www.yucklys.com/2018/11/05/%E6%90%AC%E5%AE%B6%EF%BC%81GitHub-page%E5%85%B3%E8%81%94%E5%9F%9F%E5%90%8D/"/>
    <id>http://www.yucklys.com/2018/11/05/搬家！GitHub-page关联域名/</id>
    <published>2018-11-05T04:17:33.000Z</published>
    <updated>2019-01-05T05:54:36.353Z</updated>
    
    <content type="html"><![CDATA[<p>最近有时间上<a href="https://www.godaddy.com/" target="_blank" rel="noopener">Godaddy</a>购进了一个新域名，<a href="https://yucklys.com/" target="_blank" rel="noopener">yucklys.com</a>，一番折腾之后总算是摆脱了github.io，特此做一个记录。</p><a id="more"></a><h2 id="服务选择"><a href="#服务选择" class="headerlink" title="服务选择"></a>服务选择</h2><p>由于不想去备案，并且实际上这个博客也没多少人看，所以选择了<strong>狗爹</strong>的域名。狗爹的<code>.com</code>域名还是很良心的，因为我们的https通过GitHub就可以开启，所以不用额外购买服务，而且还不需要实名认证，所以相对起来还是选择了狗爹。</p><p>具体域名怎么购买我就不赘述了，点击上方Godaddy的链接即可进入主界面，注册帐号，搜索域名，找到心仪的域名就收入囊中吧！</p><blockquote><p>喝一杯咖啡，休息一下:coffee:。</p></blockquote><p>一切都准备就绪了的话，开始搬家吧！</p><h2 id="搬家"><a href="#搬家" class="headerlink" title="搬家"></a>搬家</h2><h3 id="GitHub-CNAME配置"><a href="#GitHub-CNAME配置" class="headerlink" title="GitHub CNAME配置"></a>GitHub CNAME配置</h3><p>首先打开博客在GitHub上的地址，比如<a href="https://github.com/Yucklys/yucklys.github.io。在setting-GitHub" target="_blank" rel="noopener">https://github.com/Yucklys/yucklys.github.io。在setting-GitHub</a> Pages选项下面可以看到如下的提示：</p><blockquote><p>Your site is published at <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a></p></blockquote><p>这表明你的博客现在在yourname.github.io域名下运行着呢，现在我们需要做的就是设置一个cname记录把我们的新域名，yourname.com，添加进去。</p><p>在GitHub Pages相关选项中有一个<strong>Custom Domain</strong>选项，填写我们的域名，然后点击旁边的<strong>Save</strong>。如果一切顺利的话，在刷新后GitHub Pages下方的提示应该变成了：</p><blockquote><p>Your site is published at <a href="http://yourname.com/" target="_blank" rel="noopener">http://yourname.com/</a></p></blockquote><h3 id="Godaddy域名解析"><a href="#Godaddy域名解析" class="headerlink" title="Godaddy域名解析"></a>Godaddy域名解析</h3><p>现在让我们转移到我们的域名控制台上进行域名的解析操作。</p><p><img src="https://i.loli.net/2018/11/06/5be10e1559b33.png" alt="domain_name.png"></p><p>在Godaddy的域名管理台下需要修改的只有两处：</p><ol><li><p>修改A记录，记录值改为GitHub Page的IP地址。</p><p>注意，如果想给自己的博客加上小绿锁的话，这里的IP地址是<strong>GitHu Page的HTTPS地址</strong>。总共有四个IP地址可选，随便选择一个就好了。<a href="https://help.github.com/articles/setting-up-an-apex-domain/" target="_blank" rel="noopener">官方文档</a>已经给出了颇为详细的介绍。四个IP如下：</p></li></ol><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><ol start="2"><li><p>添加一个CNAME记录，把yourname.github.io添加进去。</p><p>这一步没什么需要注意的，如图填写即可。</p></li></ol><p>好了，现在输入你的域名，应该就可以访问你放在GitHub上的博客内容了。</p><h3 id="开启HTTPS"><a href="#开启HTTPS" class="headerlink" title="开启HTTPS"></a>开启HTTPS</h3><p>眼尖的同学就发现了，现在我们的网站只开启了http，如果是用chrome浏览的话还会被标上恼人的「不安全」。要想开启Https的话其实很简单，眼尖的同学可能也发现了，在第一步修改GitHub Page的设置的时候，有一个选项叫做<strong>Enforce HTTPS</strong>。</p><p><img src="https://blog.github.com/assets/img/2018-05-01-github-pages-custom-domains-enforce-https.png" alt="Enforce HTTPS"></p><p>只需要简单地选中选项，页面刷新后就可以看到上方的提示变为：</p><blockquote><p>Your site is published at <a href="https://yourname.com/" target="_blank" rel="noopener">https://yourname.com/</a></p></blockquote><p>但是也有可能发生一些莫名的报错，我的HTTPS无法正常使用，经过多方调查，我在GitHub文档上看到了这样一句话：<img src="https://i.loli.net/2018/11/06/5be114e1ef53e.png" alt="resolve http.png"></p><p>然后我先删除了我的<strong>Custom Domain</strong>设置，保存，然后再重新添加，保存，然后<strong>Enforce HTTPS</strong>就可以使用了。不是很清楚是什么原理，不过这样做确实是解决了我的问题。</p><p>等待一段时间后，就可以看到自己的Https博客了:smile: 。</p><h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>但是需要注意的是，GitHub Page的CNAME选项只是在项目文件夹下新建了一个CNAME(无后缀)文件，如果在本地的git项目中没有这个文件的话，下一次deploy就会把这个文件删除，导致我们需要重新配置一遍。所以在本地上的源文件内需要也新建一个CNAME文件，内容仿照GitHub中生成的CNAME文件就行。</p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">domainname.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有时间上&lt;a href=&quot;https://www.godaddy.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Godaddy&lt;/a&gt;购进了一个新域名，&lt;a href=&quot;https://yucklys.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;yucklys.com&lt;/a&gt;，一番折腾之后总算是摆脱了github.io，特此做一个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.yucklys.com/categories/Life/"/>
    
      <category term="Blog" scheme="http://www.yucklys.com/categories/Life/Blog/"/>
    
    
      <category term="Github" scheme="http://www.yucklys.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>vultr搭建SS/SSR服务</title>
    <link href="http://www.yucklys.com/2018/08/17/install-ss-with-vultr/"/>
    <id>http://www.yucklys.com/2018/08/17/install-ss-with-vultr/</id>
    <published>2018-08-17T14:24:45.000Z</published>
    <updated>2019-01-18T12:10:47.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文介绍一种使用vultr的服务器搭建SS服务的简便方法.</p></blockquote><h2 id="什么是shadowsocks"><a href="#什么是shadowsocks" class="headerlink" title="什么是shadowsocks?"></a>什么是shadowsocks?</h2><blockquote><p><strong>Shadowsocks</strong> 可以指：一种基于 <a href="https://zh.wikipedia.org/wiki/SOCKS#SOCK5" target="_blank" rel="noopener">Socks5</a> 代理方式的加密传输协议，也可以指实现这个协议的各种传输包。 Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 </p><p style="text-align:right">摘自 <a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener"><em>维基百科</em></a></p></blockquote><a id="more"></a><p>需要注意的一点是shadowsocks<strong>不是</strong>vpn, 它只是一种基于<strong>SOCKS5协议</strong>的对于网络请求的加密/解密方法, 以达到科学上网的目的.</p><h3 id="shadowsocks原理"><a href="#shadowsocks原理" class="headerlink" title="shadowsocks原理"></a>shadowsocks原理</h3><p>一般情况下, 如果在本机上想要访问<strong>外网</strong>(Google/Twitter/Youtube)是直接与远程服务建立连接并传输数据. 但在受限的网络环境下传输的数据会先经过<strong>防火墙(GFW)</strong>的检查, 如果检查出传输内容包含受限内容的话, 就会阻止此次传输, 导致无法获取远程服务数据.</p><p><img src="https://i.loli.net/2018/08/18/5b7816f16b7f3.jpg" alt="受限网络数据传输"></p><p align="”right”">图片来源: <a href="https://segmentfault.com/a/1190000011862912" target="_blank" rel="noopener">你也能写个shadowsocks</a></p><p>而shadowsocks则是根据<strong>SOCKS5</strong>协议封装的一种数据传输的方法. </p><ol><li>从主机上发出的请求会先经过本地的<strong>ss客户端(ss-local)</strong>, ss客户端会根据配置的加密方法与密码对原数据进行加密, 再将加密过的数据发送给GFW. </li><li>由于数据经过了加密, GFW无法识别出该请求是否受限, 于是通过此次请求. </li><li>按照用户配置的内容, 该被加密的数据会先发送到<strong>境外的ss服务端(ss-server)</strong>, 通过同样的算法解密后得到真正的请求数据, 然后从指定的服务器获取返回数据. </li><li>最后通过类似的过程, 受限网络的返回数据就会被主机接收到了.</li></ol><p><img src="https://i.loli.net/2018/08/18/5b781b3a9a622.jpg" alt="shadowsocks原理"></p><h3 id="为什么选择shadowsocks"><a href="#为什么选择shadowsocks" class="headerlink" title="为什么选择shadowsocks?"></a>为什么选择shadowsocks?</h3><blockquote><p>现在网上这么多vpn服务, 为什么要使用shadowsocks呢?</p></blockquote><p>shadowsocks虽然有安全问题, 如果使用他人的shadowsocks的话很容易造成个人信息泄漏. 而现在一个能够使用的vpn也比较难找, 毕竟因为众所周知的原因, vpn很容易就被查封. 就性价比来说, vpn也不如自己租的服务器.</p><p>最关键的是, 用自己的能力科学上网是非常爽的.</p><h3 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h3><p>现在知道原理了之后, 就明白实现shadowsocks有三个关键点:</p><ul><li>一台在防火墙之外的服务器</li><li>本地安装的shadowsocks客户端, 用于加密以及传输数据</li><li>安装在服务器的shadowsocks服务端, 用于解密以及数据的中转</li></ul><p>就像开头所说的, 这篇教程使用的是<strong>vultr</strong>的服务器, 最便宜的一种是<em>2.5美元/月</em>, 500G流量/月, 实际上一般人连100G都用不到. vultr的服务器是按<strong>小时计费</strong>的, 只要账户里有钱, 就会每小时自动扣除, <strong>即使关机也会计费</strong>. 另外, vultr支持<strong>支付宝</strong>.</p><blockquote><p>点击这个<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr链接</a>注册帐号并部署服务器</p></blockquote><p>对了, 本机的系统是Windows/Mac/Linux甚至手机都没关系. Windows需要安装<a href="https://pc.qq.com/detail/4/detail_2644.html" target="_blank" rel="noopener">Xshell</a>, Mac上直接使用<strong>Terminal</strong>就可以了. 这两种系统的部署接下来都会涉及到. <del>Linux没人权</del></p><p>好了, 这就开始吧!</p><p>[TOC]</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="Vultr服务器部署"><a href="#Vultr服务器部署" class="headerlink" title="Vultr服务器部署"></a>Vultr服务器部署</h2><p>注册完Vultr帐号了并且向账户内存入足够的钱后就可以开始服务器的部署了. 点击<strong>Deploy now</strong>或者<a href="https://my.vultr.com/deploy/" target="_blank" rel="noopener">部署服务器</a>进入服务器部署页面. 一次对以下内容修改:</p><ol><li><p>选择服务器位置. 这里的位置可以随意, 速度差距不大, 不过建议<strong>不要选择日本</strong>的服务器, 因为虽然日本的服务器速度最快, 但是ip常常被封, 需要经常换ip. 如果想要<a href="https://www.vultrvps.com/test-server" target="_blank" rel="noopener">测试服务器速度</a>的话可以从这个网站测试, 或者ping一下也可以.</p></li><li><p>选择服务器系统. <strong>CentOS 6+，Debian 7+，Ubuntu 12+</strong>都可以支持的, 这里建议选择<strong>Ubuntu 18.04 64bits</strong>的版本, 因为这可以方便之后用<strong>锐速</strong>或者<strong>BBR</strong>加速.</p><p><img src="https://i.loli.net/2018/08/18/5b7829bc76e37.jpg" alt="选择服务器系统"></p></li><li><p>选择价位. 值得高兴的是最近(2018.8.19)Vultr推出了全部服务器<strong>$2.5/mo</strong>的价位, 以前的话只有一些特定服务器才会有这价位, 所以机会难得. 这里选择随意, 虽然高价位提升了带宽和流量, 但说实话如果只是单人使用的话<strong>$2.5/mo</strong>就足够了.</p><p><img src="https://i.loli.net/2018/08/18/5b782bcfe904a.jpg" alt="优惠"></p></li><li><p>额外选项. 这里选择第一个<strong>Enable IPv6</strong>就可以了.</p><p><img src="https://i.loli.net/2018/08/18/5b782b53ca373.jpg" alt="Vultr额外选项"></p></li><li><p>其他选项保持默认, 点击右下<strong>Deploy Now</strong>就开始自动部署了.</p></li></ol><p>新建的服务器需要几分钟的时间部署, 这段时间可以用来下载<strong>Xshell</strong>(windows)或者吃瓜, 部署结束后在个人页面就可以看到<strong>Status</strong>显示部署完成. </p><p>点击新建的服务器, 在<strong>Overview</strong>标签下可以看到<strong>IP Address</strong>, <strong>Username</strong>, 以及<strong>Password</strong>,这三行就是之后连接服务器的关键.</p><p><img src="https://i.loli.net/2018/08/18/5b78320edfa18.png" alt="Overview"></p><h2 id="服务端ss服务搭建"><a href="#服务端ss服务搭建" class="headerlink" title="服务端ss服务搭建"></a>服务端ss服务搭建</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="连接到服务器"><a href="#连接到服务器" class="headerlink" title="连接到服务器"></a>连接到服务器</h4><p>首先需要安装有<a href="https://pc.qq.com/detail/4/detail_2644.html" target="_blank" rel="noopener">Xshell</a>, 可以通过链接或百度搜索下载.</p><ol><li>打开<em>File-New(Alt+N)</em></li></ol><p><img src="https://i.loli.net/2018/08/19/5b797bce861fc.jpg" alt="Xshell新建服务器设置"></p><ol start="2"><li><p>如图设置服务器的信息, <strong>Name</strong>是服务器的名字, 可以随便填. <strong>Host</strong>填写在Vultr注册的服务器的<strong>IP Address</strong>, 其他选项保持默认就行. </p><p><img src="https://i.loli.net/2018/08/19/5b797cc506ef6.jpg" alt="Xshell服务器IP"></p></li><li><p>接着设置用户名和密码, 用户名和密码分别是在Vultr上的<strong>Username</strong>和<strong>Password</strong>, 填写完后勾上记住用户和密码就行了.</p></li><li><p>如果如下图所示, 则表明已经连接成功了. 注意连接的服务器必须是已经部署好的. 如果没有连接成功的话就多试几次, 还不行的话就ping一下ip, 看一下是不是被墙了. 如果ping不上的话就重新再部署一个服务器吧.</p><p><img src="https://i.loli.net/2018/08/19/5b79819f3cb5c.jpg" alt="Xshell连接成功"></p></li></ol><h4 id="搭建ss服务"><a href="#搭建ss服务" class="headerlink" title="搭建ss服务"></a>搭建ss服务</h4><ol><li><p>下载一键搭建ss服务脚本, 直接复制粘贴就行了.</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure></li><li><p>运行搭建ss代码</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -i yourpassword 1024</span><br></pre></td></tr></table></figure><p>这里把<strong>yourpassword</strong>替换为你想要设置的密码就行了, 随意设定, 以后使用ss客户端就用这个密码. 后面的<strong>1024</strong>是服务的端口号, 默认是1024.</p></li><li><p>等待一会后出现成功提示就可以了.</p></li><li><p>启动服务:</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ss-fly start</span><br></pre></td></tr></table></figure><p>其他相关操作:</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">启动：/etc/init.d/ss-fly start</span><br><span class="line">停止：/etc/init.d/ss-fly stop</span><br><span class="line">重启：/etc/init.d/ss-fly restart</span><br><span class="line">状态：/etc/init.d/ss-fly status</span><br><span class="line"> </span><br><span class="line">修改配置文件：vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></li></ol><p>ss服务启动之后一般情况下不需要调整服务端了, 服务器常开就行.</p><h4 id="ss客户端"><a href="#ss客户端" class="headerlink" title="ss客户端"></a>ss客户端</h4><p>shadowsocks的官方client地址是<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">shadowsocks clients</a>, 但似乎是被墙了. windows的GUI Client可以从Github上下载.</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks-win</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks-Qt5</a></li></ul><blockquote><p>win和Qt5没什么区别, 都可以正常使用, 不过由于Qt5的全平台适用, Mac, Linux下的Qt5 Client和Windows的UI是一致的.</p></blockquote><p>除此之外, <strong>Outline</strong>也是个全平台支持的客户端, UI更好看点<del>大概吧</del>.</p><p>下载后解压启动shadowsocks, 会在右下角显示一个<img src="https://i.loli.net/2018/08/19/5b7989881e4b4.jpg" alt="">的图标,右击即可打开选项. 由于版本不同, 编辑服务器的选项位置也不同, 这里就不演示了. 服务器添加窗口打开后填写服务器相关数据即可.</p><p><img src="https://i.loli.net/2018/08/19/5b798aa7c597f.jpg" alt="客户端设置"></p><p>服务器添加成功后, 右键图标选择启动服务即可启动shadowsocks, 其他选项例如开机自启动,自动更新之类的看自己需求.</p><p>需要说明的是shadowsocks有运行两种形式. 因为shadowsocks监听所有的网络请求, 所以会把例如百度, bilibili这种国内也可以上的网站也发送到境外服务器, 导致国内的网上不去或连接慢, 并且也会耗费服务器大量流量.</p><ul><li>PAC模式: PAC模式是最常用的模式, 通过一个PAC list, shadowsocks可以知道哪些网站不需要ss也可以上, 而只在Google, Youtube这样受限网站才会启用. PAC list可以自己编写<del>傻子才自己写</del>, 也可以从网上下载, shadowsocks的客户端就有同步选项.</li><li>Global(全局)模式: 全局模式下所有的网站请求都会通过ss服务. 这个主要用于那些未被PAC收录, 你又上不去的网站. 一般来说, PAC上不去的外网开全局就能上.</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>[<a href="https://www.flyzy2005.win/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/" target="_blank" rel="noopener">一键脚本搭建SS/搭建SSR服务并开启BBR加速 | flyzy小站</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文介绍一种使用vultr的服务器搭建SS服务的简便方法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是shadowsocks&quot;&gt;&lt;a href=&quot;#什么是shadowsocks&quot; class=&quot;headerlink&quot; title=&quot;什么是shadowsocks?&quot;&gt;&lt;/a&gt;什么是shadowsocks?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Shadowsocks&lt;/strong&gt; 可以指：一种基于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/SOCKS#SOCK5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Socks5&lt;/a&gt; 代理方式的加密传输协议，也可以指实现这个协议的各种传输包。 Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 &lt;/p&gt;
&lt;p style=&quot;text-align:right&quot;&gt;摘自 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Shadowsocks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;em&gt;维基百科&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.yucklys.com/categories/Life/"/>
    
      <category term="shadowsocs" scheme="http://www.yucklys.com/categories/Life/shadowsocs/"/>
    
    
      <category term="Shadowsocks" scheme="http://www.yucklys.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Python文件打包与包内数据读写</title>
    <link href="http://www.yucklys.com/2018/07/17/Python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/"/>
    <id>http://www.yucklys.com/2018/07/17/Python包内文件/</id>
    <published>2018-07-17T02:58:03.000Z</published>
    <updated>2019-01-05T05:27:00.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编写好的Python程序想要发表或者安装到自己的电脑上，就需要<strong>打包</strong>了。打包的方式有很多种，现在常用的是引用<code>setuptools</code>写一个<code>setup.py</code>来描述打包内容，然后通过<code>python setup.py install</code>安装。在默认情况下，<code>setup.py</code>不识别数据文件或者图片，而这些数据往往是程序运行所必备的，于是就要通过一些改进来把数据文件加入包内。我在网上查找到的方法有很多，但总是无法令我满意，终于找到一个可行的方法，特此记录一下。</p><a id="more"></a><h2 id="添加数据文件到包内"><a href="#添加数据文件到包内" class="headerlink" title="添加数据文件到包内"></a>添加数据文件到包内</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><blockquote><p>在开始制作分发包之前，需要先对文件结构有一个清晰的认识，这里我用一个<code>funny_joke</code>的示例来说明一下。</p></blockquote><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  MANIFEST.in</span><br><span class="line">│  setup.py</span><br><span class="line">│  </span><br><span class="line">└─funny</span><br><span class="line">    │  main.py</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │  </span><br><span class="line">    └─data</span><br><span class="line">            funny_joke.txt</span><br></pre></td></tr></table></figure><p>这个项目的树状图如上所示，我们的主程序放在了<code>funny\main.py</code>内，而我们需要从<code>funny\data</code>中导入数据文件<code>funny_joke.txt</code>。在打包的时候我们也希望能够<strong>保持</strong>这个结构，也就是说在.egg包内数据文件的路径也是<code>funny\data\funny_joke.txt</code>。</p><h3 id="MANIFEST-in"><a href="#MANIFEST-in" class="headerlink" title="MANIFEST.in"></a>MANIFEST.in</h3><p><code>MANIFEST.in</code>文件包含Python在打包时读取的需要打包的附属文件的相对路径，当没有<code>MANIFEST.in</code>时，Python会依据<code>setup.py</code>中给出的打包文件进行打包，这种方法暂且不提。</p><p>根据文件结构，我们需要的文件在<code>funny\data</code>中。在<code>MANIFEST.in</code>中，用<code>include</code>表明需要打包的文件。</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">include funny\data\*</span><br></pre></td></tr></table></figure><p><code>*</code>表示导入所有文件，在文件路径和文件名之间有空格。</p><h3 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h3><p><code>setup.py</code>中只需要一行<code>include_package_data=True</code>就可以了，完整的代码如下：</p><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="hljs-string">'Tell a Joke'</span>,</span><br><span class="line">    version=<span class="hljs-string">'1.0.0'</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    include_package_data=<span class="hljs-keyword">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup</code>函数还有很多其他的设置，可以<a href="https://docs.python.org/3.7/distutils/setupscript.html" target="_blank" rel="noopener">查看文档</a>了解更多的配置，这里就不赘述了。</p><h2 id="读取包内文件"><a href="#读取包内文件" class="headerlink" title="读取包内文件"></a>读取包内文件</h2><p>由于安装包时文件位置的不确定，所以需要先获得当前文件的路径，再进行文件的读写。获取当前路径的方式有两种，一是通过<code>__file__</code>获取，二是通过<code>import pkg_resources</code>获取。</p><h3 id="file"><a href="#file" class="headerlink" title="__file__"></a>__file__</h3><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line">this_dir, this_filename = os.path.split(__file__)</span><br><span class="line">DATA_PATH = os.path.join(this_dir, <span class="hljs-string">"data"</span>, <span class="hljs-string">"funny_joke.txt"</span>)</span><br></pre></td></tr></table></figure><p>通过<code>os.path.spilt(__file__)</code>函数可以获得该文件的文件名和文件路径，这里我们不需要文件名，所以只关注文件路径就行了。获取了文件路径之后，通过<code>os.path.join(this_dir, &quot;path_to_the_file&quot;)</code>取得数据文件的路径，其中<code>this_dir</code>表示的是当前运行的py文件的路径，后面的<code>&quot;path_to_the_file&quot;</code>是<strong>数据文件相对于主程序的相对路径</strong>。对于示例的情况来说，代码如上。</p><blockquote><p>这个方法仅适用于数据文件的路径可以被表示的情况，在分发包（如egg）里的数据文件就无法通过这样的方式读取，其次<code>py2exe</code>打包的文件也无法读取，因为数据文件是以zip形式储存的。</p></blockquote><h3 id="pkg-resources"><a href="#pkg-resources" class="headerlink" title="pkg_resources"></a>pkg_resources</h3><figure class="highlight python hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pkg_resources</span><br><span class="line">DATA_PATH = pkg_resources.resource_filename(<span class="hljs-string">'funny.main'</span>, <span class="hljs-string">'data/funny_joke.txt'</span>)</span><br></pre></td></tr></table></figure><p><code>pke_resources.resource_filename(package_or_requirement, resource_name)</code>中，<code>package_or_requirement</code>填写的是库的名称，即<code>funny.main</code>。<code>resource_name</code>处填写数据文件相对于库文件所在路径的相对路径。</p><p>当然，<code>package_or_requirement</code>处填<code>funny</code>和<code>funny.main</code>都是一样的效果，<code>funny</code>指向的是<code>funny\__init__.py</code>，而<code>funny.main</code>指向的是<code>funny\main.py</code>，实际上都在同一个文件夹，所以对后面的<code>resource_name</code>没有影响。如果你的项目比较复杂，需要根据<code>package_or_requirement</code>填写的文件路径补充相应的相对路径。</p><p>看起来很复杂？<strong>实际上并不是!</strong><code>pkg_resources.resource_filename()</code>函数的处理方式只要理解了，就能很轻易地掌握这个方法：</p><ol><li><p>首先在包中寻找<code>funny\main.py</code>所在的文件夹。如果这个文件包含在文件夹内，那么就直接获得路径；如果这个文件被压缩成egg，那么它会解压egg文件到<code>...\Python-Eggs\Cache</code>内。这里我们的文件包含在egg文件里。</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line"><span class="hljs-meta">#</span> 先获得了这样的一个直达funny的路径</span><br></pre></td></tr></table></figure></li><li><p>之后它将<code>resource_name</code>，也就是数据文件<strong>关于<code>funny</code>的相对路径</strong>，代入到1中得到的文件夹中，如果能够找到文件（或文件夹）的话，就返回整个路径。</p><figure class="highlight shell hljs"><table><tr><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line">            └─data</span><br><span class="line">                    funny_joke.txt</span><br><span class="line"><span class="hljs-meta">#</span> 然后查找.\data\funny_joke.txt是否存在，存在则获得其路径</span><br></pre></td></tr></table></figure></li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>这两种方法各有优劣，<code>__file__</code>无法从egg或zip中获得路径，而<code>pkg_resources</code>虽然能够从egg中获取文件路径，但是当对文件进行更改的时候，只会对复制在<code>Cache</code>下的数据文件进行更改，而egg中的源文件不变。如果不小心清理了临时文件，更改过的数据文件就没了。所以说除非是<strong>特别小</strong>的数据量，或者是<strong>对数据写入没要求</strong>的程序，最好还是放在文件夹内，方便保存。</p><p>最后以一张对比表格结束战斗。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">__file__</th><th style="text-align:center">pkg_resources</th></tr></thead><tbody><tr><td style="text-align:center">适用范围</td><td style="text-align:center">文件夹内</td><td style="text-align:center">文件夹内，压缩包内</td></tr><tr><td style="text-align:center">方便程度</td><td style="text-align:center">写起来不是那么费劲，不用写绝对路径</td><td style="text-align:center">实际上获得的是一个绝对路径</td></tr><tr><td style="text-align:center">文件读写</td><td style="text-align:center">读，写（仅限文件夹）</td><td style="text-align:center">读（全方位），写(仅限文件夹）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;编写好的Python程序想要发表或者安装到自己的电脑上，就需要&lt;strong&gt;打包&lt;/strong&gt;了。打包的方式有很多种，现在常用的是引用&lt;code&gt;setuptools&lt;/code&gt;写一个&lt;code&gt;setup.py&lt;/code&gt;来描述打包内容，然后通过&lt;code&gt;python setup.py install&lt;/code&gt;安装。在默认情况下，&lt;code&gt;setup.py&lt;/code&gt;不识别数据文件或者图片，而这些数据往往是程序运行所必备的，于是就要通过一些改进来把数据文件加入包内。我在网上查找到的方法有很多，但总是无法令我满意，终于找到一个可行的方法，特此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://www.yucklys.com/categories/Programming/"/>
    
      <category term="Python" scheme="http://www.yucklys.com/categories/Programming/Python/"/>
    
    
      <category term="Road-mark" scheme="http://www.yucklys.com/tags/Road-mark/"/>
    
  </entry>
  
  <entry>
    <title>win10 第三方主题</title>
    <link href="http://www.yucklys.com/2018/07/15/win10-UltraUXThemePatcher/"/>
    <id>http://www.yucklys.com/2018/07/15/win10-UltraUXThemePatcher/</id>
    <published>2018-07-15T11:18:27.000Z</published>
    <updated>2019-01-05T05:27:00.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装windows-10第三方主题"><a href="#安装windows-10第三方主题" class="headerlink" title="安装windows 10第三方主题"></a>安装windows 10第三方主题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    Win10系统在主题的定制功能上做了削减, 导致主题只能做到更改窗口颜色等有限的改变.<img src="/images/1531654651295.png" alt="Win10主题"></p><p>​    美化后的文件管理器如上图, 破解了Windows的系统文件之后就可以有更多更酷炫的主题了, 这种主题用起来才有当初Win 7的感觉.</p><a id="more"></a><h2 id="使用UXThemePatcher破解"><a href="#使用UXThemePatcher破解" class="headerlink" title="使用UXThemePatcher破解"></a>使用UXThemePatcher破解</h2><h3 id="破解前的准备"><a href="#破解前的准备" class="headerlink" title="破解前的准备"></a>破解前的准备</h3><blockquote><p>所有的破解都是有风险的, 为了防止万恶的黑屏出现, 在开始破解前建议手动建立一个<strong>系统还原点</strong>:</p></blockquote><ol><li>打开win10自带的<strong>设置</strong>, 搜索<code>创建还原点</code>就会弹出一个窗口. 一般还原点都是设置在C盘的, 选择C盘后查看后面「保护」一项是否为「启用」，如果是就直接进入第三步，反之则看下一步。</li><li>确保选中C盘，点击「配置」，磁盘空间使用量的滑条随意，但建议1GB左右就足够了，如果以后打算长期开启这个功能的话可以调高，不过我们只是启用一次，之后就会清除还原点，毕竟系统盘空间宝贵. 之后选择「启用系统保护」就ok了。</li><li>确保选中C盘，点击「创建」，系统会自动创建一个还原点，稍等片刻直到弹出提示说明创建完成就可以了。在这段等待时间里可以先去下载我们要用的<a href="https://www.syssel.net/hoefs/software_uxtheme.php?lang=en" target="_blank" rel="noopener">UXThemePatcher</a>软件</li></ol><h3 id="UltraUXThemePatcher"><a href="#UltraUXThemePatcher" class="headerlink" title="UltraUXThemePatcher"></a>UltraUXThemePatcher</h3><ol><li>软件下载完成后是一个.exe文件，确保前期准备都做好了之后双击运行。安装过程很简单，一路回车就可以了。然后立即重启。</li><li>重启完成后，再运行一遍安装程序，其中有三项需要破解的内容，如果后面的「status」为「patched」话，就说明已经破解完成了，反之就再运行一遍，直到全部破解完毕。</li></ol><h2 id="主题的安装"><a href="#主题的安装" class="headerlink" title="主题的安装"></a>主题的安装</h2><p>​    如果你一直到现在系统还依然在正常的运行的话，那恭喜你，你可以随意安装<strong>对应版本</strong>的第三方主题了。鉴于大部分人还是翻不了墙，这里提供一个国内的<a href="http://zhutix.com/pc/" target="_blank" rel="noopener">主题网址。</a>找到喜欢的主题后只需下载并解压，然后运行.exe文件，一路默认设置安装，完成后即可在<strong>设置－个性化－主题</strong>里找到刚安装的主题了。</p><p>​    另外对于一些主题的特殊排版需要下载一些辅助软件，可以从<a href="http://zhutix.com/tools/" target="_blank" rel="noopener">这里</a>下载，一般来说<a href="http://zhutix.com/tools/oldnewexplorer/" target="_blank" rel="noopener">OldNewexplorer</a>是必备的，按照内部的教程安装就行。当然不是所有的主题都是完美无暇的，总有几个主题在自己的系统中表现不佳，这种情况也是在所难免，花点时间挑选一个在外观和细节上都很令你满意的主题就行了。</p><p>​    最后晒一晒我的桌面：</p><p><img src="https://i.loli.net/2018/11/06/5be12fdadaa51.png" alt="我的桌面Windows">我的桌面使用的软件：</p><blockquote><ul><li>Rainmeter</li><li>Wallpaper Engine</li><li>Rocket Dock</li></ul></blockquote><p>​    最后的最后，windows虽然看上去没有mac或者linux那么高端，但是经过调教后的windows也是拥有不输于另外两者的颜值的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装windows-10第三方主题&quot;&gt;&lt;a href=&quot;#安装windows-10第三方主题&quot; class=&quot;headerlink&quot; title=&quot;安装windows 10第三方主题&quot;&gt;&lt;/a&gt;安装windows 10第三方主题&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    Win10系统在主题的定制功能上做了削减, 导致主题只能做到更改窗口颜色等有限的改变.&lt;img src=&quot;/images/1531654651295.png&quot; alt=&quot;Win10主题&quot;&gt;&lt;/p&gt;
&lt;p&gt;​    美化后的文件管理器如上图, 破解了Windows的系统文件之后就可以有更多更酷炫的主题了, 这种主题用起来才有当初Win 7的感觉.&lt;/p&gt;
    
    </summary>
    
      <category term="Customization" scheme="http://www.yucklys.com/categories/Customization/"/>
    
      <category term="Beautify" scheme="http://www.yucklys.com/categories/Customization/Beautify/"/>
    
    
      <category term="Windows" scheme="http://www.yucklys.com/tags/Windows/"/>
    
      <category term="Themes" scheme="http://www.yucklys.com/tags/Themes/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github搭建自己的个人博客</title>
    <link href="http://www.yucklys.com/2018/06/29/Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.yucklys.com/2018/06/29/Hexo-github搭建自己的个人博客/</id>
    <published>2018-06-29T13:34:29.000Z</published>
    <updated>2019-01-18T12:09:18.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    现在各种个人博客的搭建方式层出不穷, 尤其是Github Pages的出现, 使得个人博客的搭建有了一种方便而又快捷的方式. 不过这里我想介绍的不是Jekyll, 而是hexo. 这里选择hexo的原因就是因为它极致的博客部署速度, 只需要小半天的时间, 一个不懂前端的人也可以照猫画虎地做出自己的个人博客.<del>我才不会说主要是因为它有官方中文文档</del></p><p>​    一个个人博客应该是什么样子的? 这一点估计每个人都有自己的想法. 对于我来说<strong>一个优秀的<del>高逼格的</del>界面是最吸引人的, 其次是优良的文章, 以及一些必不可少的功能, 比如说搜索,评论和分享.</strong> 如果建这个博客只是为了好玩的话, 建议大家大可找CSDN,简书或者其他公共博客平台, 但如果做好了折腾的准备, 为了个性化的博客不惜牺牲这点时间的话, 记住你对博客的美好想法, 然后接着往下看吧.</p><a id="more"></a><p>​    经过小半天的折腾, 最终成品就是大家现在正在看着的博客了, 总共耗时1小时. 现在博客具备的功能如下:</p><ul><li>一个优秀的界面(by next) <em>(现在是<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>)</em></li><li>评论功能(by Valine)</li><li>我的联系方式</li><li>本地搜索系统(hexo-generator-search)</li><li>标签及分类</li><li><del>评论人数统计(leancloud)</del></li></ul><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>​    首先在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上需要一个自己的项目库, 如果没有帐号的需要自己先注册一个. 新建一个repository, 项目名为<code>whatever.github.io</code>, 选择生成默认README.md. 这样一个保存博客文件的项目库就做好了.</p><p>​<img src="https://i.loli.net/2019/01/05/5c30424ba3950.png" alt="新建Repo"></p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    hexo安装前置要求是<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="noopener">git</a>, 需要先安装这两个才能安装hexo. 检测是否安装可以打开终端, 输入<code>node -v</code>和<code>git --version</code>, 如果没有报错则可以安装hexo了. 在终端输入<code>npm install -g hexo-cli</code>即可安装hexo, 输入<code>hexo -v</code>检测是否安装成功, 没有报错就可以开始初始化了.</p><p><img src="https://i.loli.net/2019/01/05/5c30424b85682.png" alt="检查安装"></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    在任意位置新建一个文件夹用来存放博客文件, 然后在终端界面打开文件夹, 输入<code>hexo init</code>即可完成初始化 , 当看到<code>INFO  Start blogging with Hexo!</code>时表明初始化完成, 此时的项目结构如下:</p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml #项目配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   └── _posts #文章存放</span><br><span class="line">└── themes #存放主题</span><br></pre></td></tr></table></figure><p>​    运行<code>npm install</code>安装依赖, 然后就可以开始配置了.</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    项目的配置在_config.yml中进行, 用任意文本编辑器打开后, 需要自己根据自己的情况更新以下版块(每一部分可以通过搜索找到):</p><ul><li>site</li><li>URL</li></ul><p><code>url</code>填写自己在github上新建的库名的github pages网址就行了(<a href="https://yourrepository)" target="_blank" rel="noopener">https://yourrepository)</a>, 比如我的就是(<a href="https://yucklys.github.io)" target="_blank" rel="noopener">https://yucklys.github.io)</a>.</p><ul><li>Deployment<br><code>type</code>填写git, 然后填写repository和branch如下</li></ul><figure class="highlight yaml hljs"><table><tr><td class="code"><pre><span class="line"><span class="hljs-attr">deploy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span></span><br><span class="line"><span class="hljs-attr">  repository:</span> <span class="hljs-string">git@github.com:Yucklys/yucklys.github.io.git</span></span><br><span class="line"><span class="hljs-attr">  branch:</span> <span class="hljs-string">master</span></span><br></pre></td></tr></table></figure><p>​    repository填写项目库SSH链接, 从项目库的clone or download选项中复制SSH链接然后粘贴, branch填写master.</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><p>​    终端输入<code>hexo g</code>生成页面, 结束后输入<code>hexo s</code>在本地服务器上显示页面, 默认端口是4000, 显示<code>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code>时打开浏览器, 输入localhost:4000并跳转即可看到自己的博客页以及初始的一个文章. </p><h3 id="上传repository"><a href="#上传repository" class="headerlink" title="上传repository"></a>上传repository</h3><p>​    首先全局声明自己身份, 在终端输入:</p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​    在终端输入<code>cd ~/.ssh</code>, 如果返回”… No such file or directory ”, 则直接输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>(<strong>邮箱换成你的邮箱</strong>). 如果能进入ssh文件夹的话则输入<code>mkdir key_backup mv id_isa* key_backup</code>备份, 然后再输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>.</p><p>​    可以一路回车, 如果想要每次输入密码的话, 也可以设置密码.</p><p>​    然后依次输入以下命令:</p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">ssh-agent -s</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>​    如果出错显示<code>Could not open a connection to your authentication agent</code>, 就输入</p><figure class="highlight plain hljs"><table><tr><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure><p>​    之后输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>复制ssh key到剪切板. 在github用户设置界面可以看到<strong>SSH and GPG keys</strong>选项, 在该项下选择New SSH key, 随便写个名字, 然后将key粘贴到key中并保存. 之后在终端中输入<code>ssh -T git@github.com</code>查看是否成功添加, 有警告就一路yes, 出现<code>Hi username! You&#39;ve successfully authenticated, but Github does not provide shell access</code>说明添加成功.</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>​    终端切换到博客文件夹, 输入<code>hexo d</code>部署, 显示<code>INFO  Deploy done: git</code>表明部署完成. 在浏览器中输入yucklys.github.io即可进入到博客界面了.</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    hexo的next主题最大的优点就是它的用户广泛, 所以大部分的功能都可以在<code>主题配置文件</code>中找到, 包含有完整的帮助文件以及众多next主题的大神用户自定义的方案, 可以说只需要<del>cv</del>简单模仿就可以做出一个不错的博客页. 当然写作的质量还是很关键的, 会用markdown是必不可少的一项技能, 这里可以去看一下hexo的<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">官方写作教程</a>, markdown的教程网上有许多, 善用google或百度.</p><hr><p>​    <em>2018.11.4更新</em></p><p>现在使用的是<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>主题，换主题有两方面原因，一是<strong>icarus</strong>的确是一款很优秀的主题，二是<strong>next</strong>用的人实在是太多了，每次看别人的博客都有种撞衫的不爽感……</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    现在各种个人博客的搭建方式层出不穷, 尤其是Github Pages的出现, 使得个人博客的搭建有了一种方便而又快捷的方式. 不过这里我想介绍的不是Jekyll, 而是hexo. 这里选择hexo的原因就是因为它极致的博客部署速度, 只需要小半天的时间, 一个不懂前端的人也可以照猫画虎地做出自己的个人博客.&lt;del&gt;我才不会说主要是因为它有官方中文文档&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;​    一个个人博客应该是什么样子的? 这一点估计每个人都有自己的想法. 对于我来说&lt;strong&gt;一个优秀的&lt;del&gt;高逼格的&lt;/del&gt;界面是最吸引人的, 其次是优良的文章, 以及一些必不可少的功能, 比如说搜索,评论和分享.&lt;/strong&gt; 如果建这个博客只是为了好玩的话, 建议大家大可找CSDN,简书或者其他公共博客平台, 但如果做好了折腾的准备, 为了个性化的博客不惜牺牲这点时间的话, 记住你对博客的美好想法, 然后接着往下看吧.&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://www.yucklys.com/categories/Life/"/>
    
      <category term="Blog" scheme="http://www.yucklys.com/categories/Life/Blog/"/>
    
    
      <category term="Github" scheme="http://www.yucklys.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>hello_world</title>
    <link href="http://www.yucklys.com/2018/06/29/hello-world/"/>
    <id>http://www.yucklys.com/2018/06/29/hello-world/</id>
    <published>2018-06-29T04:34:33.000Z</published>
    <updated>2019-01-05T05:27:00.264Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
