<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python包内文件打包与读取</title>
      <link href="/2018/07/17/Python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/"/>
      <url>/2018/07/17/Python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编写好的Python程序想要发表或者安装到自己的电脑上，就需要<strong>打包</strong>了。打包的方式有很多种，现在常用的是引用<code>setuptools</code>写一个<code>setup.py</code>来描述打包内容，然后通过<code>python setup.py install</code>安装。在默认情况下，<code>setup.py</code>不识别数据文件或者图片，而这些数据往往是程序运行所必备的，于是就要通过对<code>setup.py</code>改进来把数据文件加入包内。但是由于<code>setuptools</code>中关于添加文件的方法太多，导致常常迷惑，不知道应该选用哪种方法。这里就介绍一种<em>使用<code>MANIFEST.in</code>进行文件添加，以及文件读写的方法</em>。</p><a id="more"></a><h2 id="添加数据文件到包内"><a href="#添加数据文件到包内" class="headerlink" title="添加数据文件到包内"></a>添加数据文件到包内</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><blockquote><p>在开始制作分发包之前，需要先对文件结构有一个清晰的认识，这里我用一个<code>funny_joke</code>的示例来说明一下。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  MANIFEST.in</span><br><span class="line">│  setup.py</span><br><span class="line">│  </span><br><span class="line">└─funny</span><br><span class="line">    │  main.py</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │  </span><br><span class="line">    └─data</span><br><span class="line">            funny_joke.txt</span><br></pre></td></tr></table></figure><p>这个项目的树状图如上所示，我们的主程序放在了<code>funny\main.py</code>内，而我们需要从<code>funny\data</code>中导入数据文件<code>funny_joke.txt</code>。在打包的时候我们也希望能够<strong>保持</strong>这个结构，也就是说在.egg包内数据文件的路径也是<code>funny\data\funny_joke.txt</code>。</p><h3 id="MANIFEST-in"><a href="#MANIFEST-in" class="headerlink" title="MANIFEST.in"></a>MANIFEST.in</h3><p><code>MANIFEST.in</code>文件包含Python在打包时读取的需要打包的附属文件的相对路径，当没有<code>MANIFEST.in</code>时，Python会依据<code>setup.py</code>中给出的打包文件进行打包，这种方法暂且不提。</p><p>根据文件结构，我们需要的文件在<code>funny\data</code>中。在<code>MANIFEST.in</code>中，用<code>include</code>表明需要打包的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include funny\data\*</span><br></pre></td></tr></table></figure><p><code>*</code>表示导入所有文件，在文件路径和文件名之间有空格。</p><h3 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h3><p><code>setup.py</code>中只需要一行<code>include_package_data=True</code>就可以了，完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">'Tell a Joke'</span>,</span><br><span class="line">    version=<span class="string">'1.0.0'</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    include_package_data=<span class="keyword">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup</code>函数还有很多其他的设置，可以<a href="https://docs.python.org/3.7/distutils/setupscript.html" target="_blank" rel="noopener">查看文档</a>了解更多的配置，这里就不赘述了。</p><h2 id="读取包内文件"><a href="#读取包内文件" class="headerlink" title="读取包内文件"></a>读取包内文件</h2><p>由于安装包时文件位置的不确定，所以需要先获得当前文件的路径，再进行文件的读写。获取当前路径的方式有两种，一是通过<code>__file__</code>获取，二是通过<code>import pkg_resources</code>获取。</p><p>###__file__</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">this_dir, this_filename = os.path.split(__file__)</span><br><span class="line">DATA_PATH = os.path.join(this_dir, <span class="string">"data"</span>, <span class="string">"funny_joke.txt"</span>)</span><br></pre></td></tr></table></figure><p>通过<code>os.path.spilt(__file__)</code>函数可以获得该文件的文件名和文件路径，这里我们不需要文件名，所以只关注文件路径就行了。获取了文件路径之后，通过<code>os.path.join(this_dir, &quot;path_to_the_file&quot;)</code>取得数据文件的路径，其中<code>this_dir</code>表示的是当前运行的py文件的路径，后面的<code>&quot;path_to_the_file&quot;</code>是<strong>数据文件相对于主程序的相对路径</strong>。对于示例的情况来说，代码如上。</p><blockquote><p>这个方法仅适用于数据文件的路径可以被表示的情况，在分发包（如egg）里的数据文件就无法通过这样的方式读取，其次<code>py2exe</code>打包的文件也无法读取，因为数据文件是以zip形式储存的。</p></blockquote><h3 id="pkg-resources"><a href="#pkg-resources" class="headerlink" title="pkg_resources"></a>pkg_resources</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg_resources</span><br><span class="line">DATA_PATH = pkg_resources.resource_filename(<span class="string">'funny.main'</span>, <span class="string">'data/funny_joke.txt'</span>)</span><br></pre></td></tr></table></figure><p><code>pke_resources.resource_filename(package_or_requirement, resource_name)</code>中，<code>package_or_requirement</code>填写的是库的名称，即<code>funny.main</code>。<code>resource_name</code>处填写数据文件相对于库文件所在路径的相对路径。</p><p>当然，<code>package_or_requirement</code>处填<code>funny</code>和<code>funny.main</code>都是一样的效果，<code>funny</code>指向的是<code>funny\__init__.py</code>，而<code>funny.main</code>指向的是<code>funny\main.py</code>，实际上都在同一个文件夹，所以对后面的<code>resource_name</code>没有影响。如果你的项目比较复杂，需要根据<code>package_or_requirement</code>填写的文件路径补充相应的相对路径。</p><p>看起来很复杂？<strong>实际上并不是!</strong><code>pkg_resources.resource_filename()</code>函数的处理方式只要理解了，就能很轻易地掌握这个方法：</p><ol><li><p>首先在包中寻找<code>funny\main.py</code>所在的文件夹。如果这个文件包含在文件夹内，那么就直接获得路径；如果这个文件被压缩成egg，那么它会解压egg文件到<code>...\Python-Eggs\Cache</code>内。这里我们的文件包含在egg文件里。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line"><span class="meta">#</span> 先获得了这样的一个直达funny的路径</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>之后它将<code>resource_name</code>，也就是数据文件<strong>关于<code>funny</code>的相对路径</strong>，代入到1中得到的文件夹中，如果能够找到文件（或文件夹）的话，就返回整个路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line">            └─data</span><br><span class="line">                    funny_joke.txt</span><br><span class="line"><span class="meta">#</span> 然后查找.\data\funny_joke.txt是否存在，存在则获得其路径</span><br></pre></td></tr></table></figure></li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>这两种方法各有优劣，<code>__file__</code>无法从egg或zip中获得路径，而<code>pkg_resources</code>虽然能够从egg中获取文件路径，但是当对文件进行更改的时候，只会对复制在<code>Cache</code>下的数据文件进行更改，而egg中的源文件不变。如果不小心清理了临时文件，更改过的数据文件就没了。所以说除非是<strong>特别小</strong>的数据量，或者是<strong>对数据写入没要求</strong>的程序，最好还是放在文件夹内，方便保存。</p><p>最后以一张对比表格结束战斗。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">__file__</th><th style="text-align:center">pkg_resources</th></tr></thead><tbody><tr><td style="text-align:center">适用范围</td><td style="text-align:center">文件夹内</td><td style="text-align:center">文件夹内，压缩包内</td></tr><tr><td style="text-align:center">方便程度</td><td style="text-align:center">写起来不是那么费劲，不用写绝对路径</td><td style="text-align:center">实际上获得的是一个绝对路径</td></tr><tr><td style="text-align:center">文件读写</td><td style="text-align:center">读，写（仅限文件夹）</td><td style="text-align:center">读（全方位），写(仅限文件夹）</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序发布 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10 第三方主题</title>
      <link href="/2018/07/15/win10-UltraUXThemePatcher/"/>
      <url>/2018/07/15/win10-UltraUXThemePatcher/</url>
      <content type="html"><![CDATA[<h1 id="安装windows-10第三方主题"><a href="#安装windows-10第三方主题" class="headerlink" title="安装windows 10第三方主题"></a>安装windows 10第三方主题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    Win10系统在主题的定制功能上做了削减, 导致主题只能做到更改窗口颜色等有限的改变.<img src="images/1531654651295.png" alt=""></p><p>​    美化后的文件管理器如上图, 破解了Windows的系统文件之后就可以有更多更酷炫的主题了, 这种主题用起来才有当初Win 7的感觉.</p><a id="more"></a><!-- TOC --><h2 id="使用UXThemePatcher破解"><a href="#使用UXThemePatcher破解" class="headerlink" title="使用UXThemePatcher破解"></a>使用UXThemePatcher破解</h2><h3 id="破解前的准备"><a href="#破解前的准备" class="headerlink" title="破解前的准备"></a>破解前的准备</h3><blockquote><p>所有的破解都是有风险的, 为了防止万恶的黑屏出现, 在开始破解前建议手动建立一个<strong>系统还原点</strong>:</p></blockquote><ol><li>打开win10自带的<strong>设置</strong>, 搜索<code>创建还原点</code>就会弹出一个窗口. 一般还原点都是设置在C盘的, 选择C盘后查看后面「保护」一项是否为「启用」，如果是就直接进入第三步，反之则看下一步。</li><li>确保选中C盘，点击「配置」，磁盘空间使用量的滑条随意，但建议1GB左右就足够了，如果以后打算长期开启这个功能的话可以调高，不过我们只是启用一次，之后就会清除还原点，毕竟系统盘空间宝贵. 之后选择「启用系统保护」就ok了。</li><li>确保选中C盘，点击「创建」，系统会自动创建一个还原点，稍等片刻直到弹出提示说明创建完成就可以了。在这段等待时间里可以先去下载我们要用的<a href="https://www.syssel.net/hoefs/software_uxtheme.php?lang=en" target="_blank" rel="noopener">UXThemePatcher</a>软件</li></ol><h3 id="UltraUXThemePatcher"><a href="#UltraUXThemePatcher" class="headerlink" title="UltraUXThemePatcher"></a>UltraUXThemePatcher</h3><ol><li>软件下载完成后是一个.exe文件，确保前期准备都做好了之后双击运行。安装过程很简单，一路回车就可以了。然后立即重启。</li><li>重启完成后，再运行一遍安装程序，其中有三项需要破解的内容，如果后面的「status」为「patched」话，就说明已经破解完成了，反之就再运行一遍，直到全部破解完毕。</li></ol><h2 id="主题的安装"><a href="#主题的安装" class="headerlink" title="主题的安装"></a>主题的安装</h2><p>​    如果你一直到现在系统还依然在正常的运行的话，那恭喜你，你可以随意安装<strong>对应版本</strong>的第三方主题了。鉴于大部分人还是翻不了墙，这里提供一个国内的<a href="http://zhutix.com/pc/" target="_blank" rel="noopener">主题网址。</a>找到喜欢的主题后只需下载并解压，然后运行.exe文件，一路默认设置安装，完成后即可在<strong>设置－个性化－主题</strong>里找到刚安装的主题了。</p><p>​    另外对于一些主题的特殊排版需要下载一些辅助软件，可以从<a href="http://zhutix.com/tools/" target="_blank" rel="noopener">这里</a>下载，一般来说<a href="http://zhutix.com/tools/oldnewexplorer/" target="_blank" rel="noopener">OldNewexplorer</a>是必备的，按照内部的教程安装就行。当然不是所有的主题都是完美无暇的，总有几个主题在自己的系统中表现不佳，这种情况也是在所难免，花点时间挑选一个在外观和细节上都很令你满意的主题就行了。</p><p>​    最后晒一晒我的桌面：</p><p><img src="images\1531658329946.png" alt="我的桌面"></p><blockquote><p>我的桌面使用的软件：</p><ul><li>Rainmeter</li><li>Wallpaper Engine</li><li>Rocket Dock</li></ul></blockquote><p>​    最后的最后，windows虽然看上去没有mac或者linux那么高端，但是经过调教后的windows也是拥有不输于另外两者的颜值的。</p>]]></content>
      
      <categories>
          
          <category> customize </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+github搭建自己的个人博客</title>
      <link href="/2018/06/29/Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/29/Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h1 id="使用hexo-github搭建自己的个人博客"><a href="#使用hexo-github搭建自己的个人博客" class="headerlink" title="使用hexo+github搭建自己的个人博客"></a>使用hexo+github搭建自己的个人博客</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    现在各种个人博客的搭建方式层出不穷, 尤其是Github Pages的出现, 使得个人博客的搭建有了一种方便而又快捷的方式. 不过这里我想介绍的不是Jekyll, 而是hexo. 这里选择hexo的原因就是因为它极致的博客部署速度, 只需要小半天的时间, 一个不懂前端的人也可以照猫画虎地做出自己的个人博客.<del>我才不会说主要是因为它有官方中文文档</del></p><p>​    一个个人博客应该是什么样子的? 这一点估计每个人都有自己的想法. 对于我来说<strong>一个优秀的<del>高逼格的</del>界面是最吸引人的, 其次是优良的文章, 以及一些必不可少的功能, 比如说搜索,评论和分享.</strong> 如果建这个博客只是为了好玩的话, 建议大家大可找CSDN,简书或者其他公共博客平台, 但如果做好了折腾的准备, 为了个性化的博客不惜牺牲这点时间的话, 记住你对博客的美好想法, 然后接着往下看吧.</p><a id="more"></a><p>​    经过小半天的折腾, 最终成品就是大家现在正在看着的博客了, 总共耗时1小时. 现在博客具备的功能如下:</p><ul><li>一个优秀的界面(by next)</li><li>评论功能(by Valine)</li><li>我的联系方式</li><li>本地搜索系统(hexo-generator-search)</li><li>标签及分类</li><li>评论人数统计(leancloud)</li></ul><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>​    首先在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上需要一个自己的项目库, 如果没有帐号的需要自己先注册一个. 新建一个repository, 项目名为<code>whatever.github.io</code>, 选择生成默认README.md. 这样一个保存博客文件的项目库就做好了.</p><p>​    <img src="images/Github_new_repo.png" alt=""></p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    hexo安装前置要求是<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="noopener">git</a>, 需要先安装这两个才能安装hexo. 检测是否安装可以打开终端, 输入<code>node -v</code>和<code>git --version</code>, 如果没有报错则可以安装hexo了. 在终端输入<code>npm install -g hexo-cli</code>即可安装hexo, 输入<code>hexo -v</code>检测是否安装成功, 没有报错就可以开始初始化了.</p><p><img src="images/check_install.png" alt=""></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    在任意位置新建一个文件夹用来存放博客文件, 然后在终端界面打开文件夹, 输入<code>hexo init</code>即可完成初始化 , 当看到<code>INFO  Start blogging with Hexo!</code>时表明初始化完成, 此时的项目结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml #项目配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   └── _posts #文章存放</span><br><span class="line">└── themes #存放主题</span><br></pre></td></tr></table></figure><p>​    运行<code>npm install</code>安装依赖, 然后就可以开始配置了.</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    项目的配置在_config.yml中进行, 用任意文本编辑器打开后, 需要自己根据自己的情况更新以下版块(每一部分可以通过搜索找到):</p><ul><li>site</li><li>URL</li></ul><p><code>url</code>填写自己在github上新建的库名的github pages网址就行了(<a href="https://yourrepository)" target="_blank" rel="noopener">https://yourrepository)</a>, 比如我的就是(<a href="https://yucklys.github.io)">https://yucklys.github.io)</a>.</p><ul><li>Deployment<br><code>type</code>填写git, 然后填写repository和branch如下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:Yucklys/yucklys.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>​    repository填写项目库SSH链接, 从项目库的clone or download选项中复制SSH链接然后粘贴, branch填写master.</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><p>​    终端输入<code>hexo g</code>生成页面, 结束后输入<code>hexo s</code>在本地服务器上显示页面, 默认端口是4000, 显示<code>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code>时打开浏览器, 输入localhost:4000并跳转即可看到自己的博客页以及初始的一个文章. </p><h3 id="上传repository"><a href="#上传repository" class="headerlink" title="上传repository"></a>上传repository</h3><p>​    首先全局声明自己身份, 在终端输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​    在终端输入<code>cd ~/.ssh</code>, 如果返回”… No such file or directory ”, 则直接输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>(<strong>邮箱换成你的邮箱</strong>). 如果能进入ssh文件夹的话则输入<code>mkdir key_backup mv id_isa* key_backup</code>备份, 然后再输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>.</p><p>​    可以一路回车, 如果想要每次输入密码的话, 也可以设置密码.</p><p>​    然后依次输入以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -s</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>​    如果出错显示<code>Could not open a connection to your authentication agent</code>, 就输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure><p>​    之后输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>复制ssh key到剪切板. 在github用户设置界面可以看到<strong>SSH and GPG keys</strong>选项, 在该项下选择New SSH key, 随便写个名字, 然后将key粘贴到key中并保存. 之后在终端中输入<code>ssh -T git@github.com</code>查看是否成功添加, 有警告就一路yes, 出现<code>Hi username! You&#39;ve successfully authenticated, but Github does not provide shell access</code>说明添加成功.</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>​    终端切换到博客文件夹, 输入<code>hexo d</code>部署, 显示<code>INFO  Deploy done: git</code>表明部署完成. 在浏览器中输入yucklys.github.io即可进入到博客界面了.</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    hexo的next主题最大的优点就是它的用户广泛, 所以大部分的功能都可以在<code>主题配置文件</code>中找到, 包含有完整的帮助文件以及众多next主题的大神用户自定义的方案, 可以说只需要<del>cv</del>简单模仿就可以做出一个不错的博客页. 当然写作的质量还是很关键的, 会用markdown是必不可少的一项技能, 这里可以去看一下hexo的<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">官方写作教程</a>, markdown的教程网上有许多, 善用google或百度.</p><p>​    最后祝大家享受美好生活!</p>]]></content>
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello_world</title>
      <link href="/2018/06/29/hello-world/"/>
      <url>/2018/06/29/hello-world/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
  
  
</search>
