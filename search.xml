<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>vultr搭建SS/SSR服务</title>
      <link href="/2018/08/17/install-ss-with-vultr/"/>
      <url>/2018/08/17/install-ss-with-vultr/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文介绍一种使用vultr的服务器搭建SS服务的简便方法.</p></blockquote><h2 id="什么是shadowsocks"><a href="#什么是shadowsocks" class="headerlink" title="什么是shadowsocks?"></a>什么是shadowsocks?</h2><blockquote><p><strong>Shadowsocks</strong> 可以指：一种基于 <a href="https://zh.wikipedia.org/wiki/SOCKS#SOCK5" target="_blank" rel="noopener">Socks5</a> 代理方式的加密传输协议，也可以指实现这个协议的各种传输包。 Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 </p><p style="text-align:right">摘自 <a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener"><em>维基百科</em></a></p></blockquote><a id="more"></a><p>需要注意的一点是shadowsocks<strong>不是</strong>vpn, 它只是一种基于<strong>SOCKS5协议</strong>的对于网络请求的加密/解密方法, 以达到科学上网的目的.</p><h3 id="shadowsocks原理"><a href="#shadowsocks原理" class="headerlink" title="shadowsocks原理"></a>shadowsocks原理</h3><p>一般情况下, 如果在本机上想要访问<strong>外网</strong>(Google/Twitter/Youtube)是直接与远程服务建立连接并传输数据. 但在受限的网络环境下传输的数据会先经过<strong>防火墙(GFW)</strong>的检查, 如果检查出传输内容包含受限内容的话, 就会阻止此次传输, 导致无法获取远程服务数据.</p><p><img src="https://i.loli.net/2018/08/18/5b7816f16b7f3.jpg" alt="受限网络数据传输"></p><p align="”right”">图片来源: <a href="https://segmentfault.com/a/1190000011862912" target="_blank" rel="noopener">你也能写个shadowsocks</a></p><p>而shadowsocks则是根据<strong>SOCKS5</strong>协议封装的一种数据传输的方法. </p><ol><li>从主机上发出的请求会先经过本地的<strong>ss客户端(ss-local)</strong>, ss客户端会根据配置的加密方法与密码对原数据进行加密, 再将加密过的数据发送给GFW. </li><li>由于数据经过了加密, GFW无法识别出该请求是否受限, 于是通过此次请求. </li><li>按照用户配置的内容, 该被加密的数据会先发送到<strong>境外的ss服务端(ss-server)</strong>, 通过同样的算法解密后得到真正的请求数据, 然后从指定的服务器获取返回数据. </li><li>最后通过类似的过程, 受限网络的返回数据就会被主机接收到了.</li></ol><p><img src="https://i.loli.net/2018/08/18/5b781b3a9a622.jpg" alt="shadowsocks原理"></p><h3 id="为什么选择shadowsocks"><a href="#为什么选择shadowsocks" class="headerlink" title="为什么选择shadowsocks?"></a>为什么选择shadowsocks?</h3><blockquote><p>现在网上这么多vpn服务, 为什么要使用shadowsocks呢?</p></blockquote><p>shadowsocks虽然有安全问题, 如果使用他人的shadowsocks的话很容易造成个人信息泄漏. 而现在一个能够使用的vpn也比较难找, 毕竟因为众所周知的原因, vpn很容易就被查封. 就性价比来说, vpn也不如自己租的服务器.</p><p>最关键的是, 用自己的能力科学上网是非常爽的.</p><h3 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h3><p>现在知道原理了之后, 就明白实现shadowsocks有三个关键点:</p><ul><li>一台在防火墙之外的服务器</li><li>本地安装的shadowsocks客户端, 用于加密以及传输数据</li><li>安装在服务器的shadowsocks服务端, 用于解密以及数据的中转</li></ul><p>就像开头所说的, 这篇教程使用的是<strong>vultr</strong>的服务器, 最便宜的一种是<em>2.5美元/月</em>, 500G流量/月, 实际上一般人连100G都用不到. vultr的服务器是按<strong>小时计费</strong>的, 只要账户里有钱, 就会每小时自动扣除, <strong>即使关机也会计费</strong>. 另外, vultr支持<strong>支付宝</strong>.</p><blockquote><p>点击这个<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr链接</a>注册帐号并部署服务器</p></blockquote><p>对了, 本机的系统是Windows/Mac/Linux甚至手机都没关系. Windows需要安装<a href="https://pc.qq.com/detail/4/detail_2644.html" target="_blank" rel="noopener">Xshell</a>, Mac上直接使用<strong>Terminal</strong>就可以了. 这两种系统的部署接下来都会涉及到. <del>Linux没人权</del></p><p>好了, 这就开始吧!</p><p>[TOC]</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="Vultr服务器部署"><a href="#Vultr服务器部署" class="headerlink" title="Vultr服务器部署"></a>Vultr服务器部署</h2><p>注册完Vultr帐号了并且向账户内存入足够的钱后就可以开始服务器的部署了. 点击<strong>Deploy now</strong>或者<a href="https://my.vultr.com/deploy/" target="_blank" rel="noopener">部署服务器</a>进入服务器部署页面. 一次对以下内容修改:</p><ol><li><p>选择服务器位置. 这里的位置可以随意, 速度差距不大, 不过建议<strong>不要选择日本</strong>的服务器, 因为虽然日本的服务器速度最快, 但是ip常常被封, 需要经常换ip. 如果想要<a href="https://www.vultrvps.com/test-server" target="_blank" rel="noopener">测试服务器速度</a>的话可以从这个网站测试, 或者ping一下也可以.</p></li><li><p>选择服务器系统. <strong>CentOS 6+，Debian 7+，Ubuntu 12+</strong>都可以支持的, 这里建议选择<strong>Ubuntu 18.04 64bits</strong>的版本, 因为这可以方便之后用<strong>锐速</strong>或者<strong>BBR</strong>加速.</p><p><img src="https://i.loli.net/2018/08/18/5b7829bc76e37.jpg" alt="选择服务器系统"></p></li><li><p>选择价位. 值得高兴的是最近(2018.8.19)Vultr推出了全部服务器<strong>$2.5/mo</strong>的价位, 以前的话只有一些特定服务器才会有这价位, 所以机会难得. 这里选择随意, 虽然高价位提升了带宽和流量, 但说实话如果只是单人使用的话<strong>$2.5/mo</strong>就足够了.</p><p><img src="https://i.loli.net/2018/08/18/5b782bcfe904a.jpg" alt="优惠"></p></li><li><p>额外选项. 这里选择第一个<strong>Enable IPv6</strong>就可以了.</p><p><img src="https://i.loli.net/2018/08/18/5b782b53ca373.jpg" alt="Vultr额外选项"></p></li><li><p>其他选项保持默认, 点击右下<strong>Deploy Now</strong>就开始自动部署了.</p></li></ol><p>新建的服务器需要几分钟的时间部署, 这段时间可以用来下载<strong>Xshell</strong>(windows)或者吃瓜, 部署结束后在个人页面就可以看到<strong>Status</strong>显示部署完成. </p><p>点击新建的服务器, 在<strong>Overview</strong>标签下可以看到<strong>IP Address</strong>, <strong>Username</strong>, 以及<strong>Password</strong>,这三行就是之后连接服务器的关键.</p><p><img src="https://i.loli.net/2018/08/18/5b78320edfa18.png" alt="Overview"></p><h2 id="服务端ss服务搭建"><a href="#服务端ss服务搭建" class="headerlink" title="服务端ss服务搭建"></a>服务端ss服务搭建</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="连接到服务器"><a href="#连接到服务器" class="headerlink" title="连接到服务器"></a>连接到服务器</h4><p>首先需要安装有<a href="https://pc.qq.com/detail/4/detail_2644.html" target="_blank" rel="noopener">Xshell</a>, 可以通过链接或百度搜索下载.</p><ol><li>打开<em>File-New(Alt+N)</em></li></ol><p><img src="https://i.loli.net/2018/08/19/5b797bce861fc.jpg" alt="Xshell新建服务器设置"></p><ol start="2"><li><p>如图设置服务器的信息, <strong>Name</strong>是服务器的名字, 可以随便填. <strong>Host</strong>填写在Vultr注册的服务器的<strong>IP Address</strong>, 其他选项保持默认就行. </p><p><img src="https://i.loli.net/2018/08/19/5b797cc506ef6.jpg" alt="Xshell服务器IP"></p></li><li><p>接着设置用户名和密码, 用户名和密码分别是在Vultr上的<strong>Username</strong>和<strong>Password</strong>, 填写完后勾上记住用户和密码就行了.</p></li><li><p>如果如下图所示, 则表明已经连接成功了. 注意连接的服务器必须是已经部署好的. 如果没有连接成功的话就多试几次, 还不行的话就ping一下ip, 看一下是不是被墙了. 如果ping不上的话就重新再部署一个服务器吧.</p><p><img src="https://i.loli.net/2018/08/19/5b79819f3cb5c.jpg" alt="Xshell连接成功"></p></li></ol><h4 id="搭建ss服务"><a href="#搭建ss服务" class="headerlink" title="搭建ss服务"></a>搭建ss服务</h4><ol><li><p>下载一键搭建ss服务脚本, 直接复制粘贴就行了.</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure></li><li><p>运行搭建ss代码</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -i yourpassword 1024</span><br></pre></td></tr></table></figure><p>这里把<strong>yourpassword</strong>替换为你想要设置的密码就行了, 随意设定, 以后使用ss客户端就用这个密码. 后面的<strong>1024</strong>是服务的端口号, 默认是1024.</p></li><li><p>等待一会后出现成功提示就可以了.</p></li><li><p>启动服务:</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ss-fly start</span><br></pre></td></tr></table></figure><p>其他相关操作:</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">启动：/etc/init.d/ss-fly start</span><br><span class="line">停止：/etc/init.d/ss-fly stop</span><br><span class="line">重启：/etc/init.d/ss-fly restart</span><br><span class="line">状态：/etc/init.d/ss-fly status</span><br><span class="line"> </span><br><span class="line">修改配置文件：vim /etc/shadowsocks.json</span><br></pre></td></tr></table></figure></li></ol><p>ss服务启动之后一般情况下不需要调整服务端了, 服务器常开就行.</p><h4 id="ss客户端"><a href="#ss客户端" class="headerlink" title="ss客户端"></a>ss客户端</h4><p>shadowsocks的官方client地址是<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">shadowsocks clients</a>, 但似乎是被墙了. windows的GUI Client可以从Github上下载.</p><ul><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks-win</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks-Qt5</a></li></ul><blockquote><p>win和Qt5没什么区别, 都可以正常使用, 不过由于Qt5的全平台适用, Mac, Linux下的Qt5 Client和Windows的UI是一致的.</p></blockquote><p>除此之外, <strong>Outline</strong>也是个全平台支持的客户端, UI更好看点<del>大概吧</del>.</p><p>下载后解压启动shadowsocks, 会在右下角显示一个<img src="https://i.loli.net/2018/08/19/5b7989881e4b4.jpg" alt="">的图标,右击即可打开选项. 由于版本不同, 编辑服务器的选项位置也不同, 这里就不演示了. 服务器添加窗口打开后填写服务器相关数据即可.</p><p><img src="https://i.loli.net/2018/08/19/5b798aa7c597f.jpg" alt="客户端设置"></p><p>服务器添加成功后, 右键图标选择启动服务即可启动shadowsocks, 其他选项例如开机自启动,自动更新之类的看自己需求.</p><p>需要说明的是shadowsocks有运行两种形式. 因为shadowsocks监听所有的网络请求, 所以会把例如百度, bilibili这种国内也可以上的网站也发送到境外服务器, 导致国内的网上不去或连接慢, 并且也会耗费服务器大量流量.</p><ul><li>PAC模式: PAC模式是最常用的模式, 通过一个PAC list, shadowsocks可以知道哪些网站不需要ss也可以上, 而只在Google, Youtube这样受限网站才会启用. PAC list可以自己编写<del>傻子才自己写</del>, 也可以从网上下载, shadowsocks的客户端就有同步选项.</li><li>Global(全局)模式: 全局模式下所有的网站请求都会通过ss服务. 这个主要用于那些未被PAC收录, 你又上不去的网站. 一般来说, PAC上不去的外网开全局就能上.</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>[<a href="https://www.flyzy2005.win/fan-qiang/shadowsocks/install-shadowsocks-in-one-command/" target="_blank" rel="noopener">一键脚本搭建SS/搭建SSR服务并开启BBR加速 | flyzy小站</a>]</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vultr </tag>
            
            <tag> VPS </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python文件打包与包内数据读写</title>
      <link href="/2018/07/17/Python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/"/>
      <url>/2018/07/17/Python%E5%8C%85%E5%86%85%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编写好的Python程序想要发表或者安装到自己的电脑上，就需要<strong>打包</strong>了。打包的方式有很多种，现在常用的是引用<code>setuptools</code>写一个<code>setup.py</code>来描述打包内容，然后通过<code>python setup.py install</code>安装。在默认情况下，<code>setup.py</code>不识别数据文件或者图片，而这些数据往往是程序运行所必备的，于是就要通过一些改进来把数据文件加入包内。我在网上查找到的方法有很多，但总是无法令我满意，终于找到一个可行的方法，特此记录一下。</p><a id="more"></a><h2 id="添加数据文件到包内"><a href="#添加数据文件到包内" class="headerlink" title="添加数据文件到包内"></a>添加数据文件到包内</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><blockquote><p>在开始制作分发包之前，需要先对文件结构有一个清晰的认识，这里我用一个<code>funny_joke</code>的示例来说明一下。</p></blockquote><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E:.</span><br><span class="line">│  MANIFEST.in</span><br><span class="line">│  setup.py</span><br><span class="line">│  </span><br><span class="line">└─funny</span><br><span class="line">    │  main.py</span><br><span class="line">    │  __init__.py</span><br><span class="line">    │  </span><br><span class="line">    └─data</span><br><span class="line">            funny_joke.txt</span><br></pre></td></tr></table></figure><p>这个项目的树状图如上所示，我们的主程序放在了<code>funny\main.py</code>内，而我们需要从<code>funny\data</code>中导入数据文件<code>funny_joke.txt</code>。在打包的时候我们也希望能够<strong>保持</strong>这个结构，也就是说在.egg包内数据文件的路径也是<code>funny\data\funny_joke.txt</code>。</p><h3 id="MANIFEST-in"><a href="#MANIFEST-in" class="headerlink" title="MANIFEST.in"></a>MANIFEST.in</h3><p><code>MANIFEST.in</code>文件包含Python在打包时读取的需要打包的附属文件的相对路径，当没有<code>MANIFEST.in</code>时，Python会依据<code>setup.py</code>中给出的打包文件进行打包，这种方法暂且不提。</p><p>根据文件结构，我们需要的文件在<code>funny\data</code>中。在<code>MANIFEST.in</code>中，用<code>include</code>表明需要打包的文件。</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include funny\data\*</span><br></pre></td></tr></table></figure><p><code>*</code>表示导入所有文件，在文件路径和文件名之间有空格。</p><h3 id="setup-py"><a href="#setup-py" class="headerlink" title="setup.py"></a>setup.py</h3><p><code>setup.py</code>中只需要一行<code>include_package_data=True</code>就可以了，完整的代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="hljs-string">'Tell a Joke'</span>,</span><br><span class="line">    version=<span class="hljs-string">'1.0.0'</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    include_package_data=<span class="hljs-keyword">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>setup</code>函数还有很多其他的设置，可以<a href="https://docs.python.org/3.7/distutils/setupscript.html" target="_blank" rel="noopener">查看文档</a>了解更多的配置，这里就不赘述了。</p><h2 id="读取包内文件"><a href="#读取包内文件" class="headerlink" title="读取包内文件"></a>读取包内文件</h2><p>由于安装包时文件位置的不确定，所以需要先获得当前文件的路径，再进行文件的读写。获取当前路径的方式有两种，一是通过<code>__file__</code>获取，二是通过<code>import pkg_resources</code>获取。</p><h3 id="file"><a href="#file" class="headerlink" title="__file__"></a>__file__</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line">this_dir, this_filename = os.path.split(__file__)</span><br><span class="line">DATA_PATH = os.path.join(this_dir, <span class="hljs-string">"data"</span>, <span class="hljs-string">"funny_joke.txt"</span>)</span><br></pre></td></tr></table></figure><p>通过<code>os.path.spilt(__file__)</code>函数可以获得该文件的文件名和文件路径，这里我们不需要文件名，所以只关注文件路径就行了。获取了文件路径之后，通过<code>os.path.join(this_dir, &quot;path_to_the_file&quot;)</code>取得数据文件的路径，其中<code>this_dir</code>表示的是当前运行的py文件的路径，后面的<code>&quot;path_to_the_file&quot;</code>是<strong>数据文件相对于主程序的相对路径</strong>。对于示例的情况来说，代码如上。</p><blockquote><p>这个方法仅适用于数据文件的路径可以被表示的情况，在分发包（如egg）里的数据文件就无法通过这样的方式读取，其次<code>py2exe</code>打包的文件也无法读取，因为数据文件是以zip形式储存的。</p></blockquote><h3 id="pkg-resources"><a href="#pkg-resources" class="headerlink" title="pkg_resources"></a>pkg_resources</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> pkg_resources</span><br><span class="line">DATA_PATH = pkg_resources.resource_filename(<span class="hljs-string">'funny.main'</span>, <span class="hljs-string">'data/funny_joke.txt'</span>)</span><br></pre></td></tr></table></figure><p><code>pke_resources.resource_filename(package_or_requirement, resource_name)</code>中，<code>package_or_requirement</code>填写的是库的名称，即<code>funny.main</code>。<code>resource_name</code>处填写数据文件相对于库文件所在路径的相对路径。</p><p>当然，<code>package_or_requirement</code>处填<code>funny</code>和<code>funny.main</code>都是一样的效果，<code>funny</code>指向的是<code>funny\__init__.py</code>，而<code>funny.main</code>指向的是<code>funny\main.py</code>，实际上都在同一个文件夹，所以对后面的<code>resource_name</code>没有影响。如果你的项目比较复杂，需要根据<code>package_or_requirement</code>填写的文件路径补充相应的相对路径。</p><p>看起来很复杂？<strong>实际上并不是!</strong><code>pkg_resources.resource_filename()</code>函数的处理方式只要理解了，就能很轻易地掌握这个方法：</p><ol><li><p>首先在包中寻找<code>funny\main.py</code>所在的文件夹。如果这个文件包含在文件夹内，那么就直接获得路径；如果这个文件被压缩成egg，那么它会解压egg文件到<code>...\Python-Eggs\Cache</code>内。这里我们的文件包含在egg文件里。</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line"><span class="hljs-meta">#</span> 先获得了这样的一个直达funny的路径</span><br></pre></td></tr></table></figure></li><li><p>之后它将<code>resource_name</code>，也就是数据文件<strong>关于<code>funny</code>的相对路径</strong>，代入到1中得到的文件夹中，如果能够找到文件（或文件夹）的话，就返回整个路径。</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">└─Cache</span><br><span class="line">    └─tell_a_joke-1.0.0-py3.5.egg-tmp</span><br><span class="line">        └─funny</span><br><span class="line">            └─data</span><br><span class="line">                    funny_joke.txt</span><br><span class="line"><span class="hljs-meta">#</span> 然后查找.\data\funny_joke.txt是否存在，存在则获得其路径</span><br></pre></td></tr></table></figure></li></ol><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>这两种方法各有优劣，<code>__file__</code>无法从egg或zip中获得路径，而<code>pkg_resources</code>虽然能够从egg中获取文件路径，但是当对文件进行更改的时候，只会对复制在<code>Cache</code>下的数据文件进行更改，而egg中的源文件不变。如果不小心清理了临时文件，更改过的数据文件就没了。所以说除非是<strong>特别小</strong>的数据量，或者是<strong>对数据写入没要求</strong>的程序，最好还是放在文件夹内，方便保存。</p><p>最后以一张对比表格结束战斗。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">__file__</th><th style="text-align:center">pkg_resources</th></tr></thead><tbody><tr><td style="text-align:center">适用范围</td><td style="text-align:center">文件夹内</td><td style="text-align:center">文件夹内，压缩包内</td></tr><tr><td style="text-align:center">方便程度</td><td style="text-align:center">写起来不是那么费劲，不用写绝对路径</td><td style="text-align:center">实际上获得的是一个绝对路径</td></tr><tr><td style="text-align:center">文件读写</td><td style="text-align:center">读，写（仅限文件夹）</td><td style="text-align:center">读（全方位），写(仅限文件夹）</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Road mark </tag>
            
            <tag> Build </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win10 第三方主题</title>
      <link href="/2018/07/15/win10-UltraUXThemePatcher/"/>
      <url>/2018/07/15/win10-UltraUXThemePatcher/</url>
      <content type="html"><![CDATA[<h1 id="安装windows-10第三方主题"><a href="#安装windows-10第三方主题" class="headerlink" title="安装windows 10第三方主题"></a>安装windows 10第三方主题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    Win10系统在主题的定制功能上做了削减, 导致主题只能做到更改窗口颜色等有限的改变.<img src="/images/1531654651295.png" alt=""></p><p>​    美化后的文件管理器如上图, 破解了Windows的系统文件之后就可以有更多更酷炫的主题了, 这种主题用起来才有当初Win 7的感觉.</p><a id="more"></a><h2 id="使用UXThemePatcher破解"><a href="#使用UXThemePatcher破解" class="headerlink" title="使用UXThemePatcher破解"></a>使用UXThemePatcher破解</h2><h3 id="破解前的准备"><a href="#破解前的准备" class="headerlink" title="破解前的准备"></a>破解前的准备</h3><blockquote><p>所有的破解都是有风险的, 为了防止万恶的黑屏出现, 在开始破解前建议手动建立一个<strong>系统还原点</strong>:</p></blockquote><ol><li>打开win10自带的<strong>设置</strong>, 搜索<code>创建还原点</code>就会弹出一个窗口. 一般还原点都是设置在C盘的, 选择C盘后查看后面「保护」一项是否为「启用」，如果是就直接进入第三步，反之则看下一步。</li><li>确保选中C盘，点击「配置」，磁盘空间使用量的滑条随意，但建议1GB左右就足够了，如果以后打算长期开启这个功能的话可以调高，不过我们只是启用一次，之后就会清除还原点，毕竟系统盘空间宝贵. 之后选择「启用系统保护」就ok了。</li><li>确保选中C盘，点击「创建」，系统会自动创建一个还原点，稍等片刻直到弹出提示说明创建完成就可以了。在这段等待时间里可以先去下载我们要用的<a href="https://www.syssel.net/hoefs/software_uxtheme.php?lang=en" target="_blank" rel="noopener">UXThemePatcher</a>软件</li></ol><h3 id="UltraUXThemePatcher"><a href="#UltraUXThemePatcher" class="headerlink" title="UltraUXThemePatcher"></a>UltraUXThemePatcher</h3><ol><li>软件下载完成后是一个.exe文件，确保前期准备都做好了之后双击运行。安装过程很简单，一路回车就可以了。然后立即重启。</li><li>重启完成后，再运行一遍安装程序，其中有三项需要破解的内容，如果后面的「status」为「patched」话，就说明已经破解完成了，反之就再运行一遍，直到全部破解完毕。</li></ol><h2 id="主题的安装"><a href="#主题的安装" class="headerlink" title="主题的安装"></a>主题的安装</h2><p>​    如果你一直到现在系统还依然在正常的运行的话，那恭喜你，你可以随意安装<strong>对应版本</strong>的第三方主题了。鉴于大部分人还是翻不了墙，这里提供一个国内的<a href="http://zhutix.com/pc/" target="_blank" rel="noopener">主题网址。</a>找到喜欢的主题后只需下载并解压，然后运行.exe文件，一路默认设置安装，完成后即可在<strong>设置－个性化－主题</strong>里找到刚安装的主题了。</p><p>​    另外对于一些主题的特殊排版需要下载一些辅助软件，可以从<a href="http://zhutix.com/tools/" target="_blank" rel="noopener">这里</a>下载，一般来说<a href="http://zhutix.com/tools/oldnewexplorer/" target="_blank" rel="noopener">OldNewexplorer</a>是必备的，按照内部的教程安装就行。当然不是所有的主题都是完美无暇的，总有几个主题在自己的系统中表现不佳，这种情况也是在所难免，花点时间挑选一个在外观和细节上都很令你满意的主题就行了。</p><p>​    最后晒一晒我的桌面：</p><p><img src="/images/1531658329946.png" alt="我的桌面"></p><blockquote><p>我的桌面使用的软件：</p><ul><li>Rainmeter</li><li>Wallpaper Engine</li><li>Rocket Dock</li></ul></blockquote><p>​    最后的最后，windows虽然看上去没有mac或者linux那么高端，但是经过调教后的windows也是拥有不输于另外两者的颜值的。</p>]]></content>
      
      <categories>
          
          <category> Customization </category>
          
          <category> Beautify </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Themes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+github搭建自己的个人博客</title>
      <link href="/2018/06/29/Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/29/Hexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    现在各种个人博客的搭建方式层出不穷, 尤其是Github Pages的出现, 使得个人博客的搭建有了一种方便而又快捷的方式. 不过这里我想介绍的不是Jekyll, 而是hexo. 这里选择hexo的原因就是因为它极致的博客部署速度, 只需要小半天的时间, 一个不懂前端的人也可以照猫画虎地做出自己的个人博客.<del>我才不会说主要是因为它有官方中文文档</del></p><p>​    一个个人博客应该是什么样子的? 这一点估计每个人都有自己的想法. 对于我来说<strong>一个优秀的<del>高逼格的</del>界面是最吸引人的, 其次是优良的文章, 以及一些必不可少的功能, 比如说搜索,评论和分享.</strong> 如果建这个博客只是为了好玩的话, 建议大家大可找CSDN,简书或者其他公共博客平台, 但如果做好了折腾的准备, 为了个性化的博客不惜牺牲这点时间的话, 记住你对博客的美好想法, 然后接着往下看吧.</p><a id="more"></a><p>​    经过小半天的折腾, 最终成品就是大家现在正在看着的博客了, 总共耗时1小时. 现在博客具备的功能如下:</p><ul><li>一个优秀的界面(by next) <em>(现在是<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>)</em></li><li>评论功能(by Valine)</li><li>我的联系方式</li><li>本地搜索系统(hexo-generator-search)</li><li>标签及分类</li><li><del>评论人数统计(leancloud)</del></li></ul><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>​    首先在<a href="https://github.com/" target="_blank" rel="noopener">github</a>上需要一个自己的项目库, 如果没有帐号的需要自己先注册一个. 新建一个repository, 项目名为<code>whatever.github.io</code>, 选择生成默认README.md. 这样一个保存博客文件的项目库就做好了.</p><p>​    <img src="images/Github_new_repo.png" alt=""></p><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    hexo安装前置要求是<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="noopener">git</a>, 需要先安装这两个才能安装hexo. 检测是否安装可以打开终端, 输入<code>node -v</code>和<code>git --version</code>, 如果没有报错则可以安装hexo了. 在终端输入<code>npm install -g hexo-cli</code>即可安装hexo, 输入<code>hexo -v</code>检测是否安装成功, 没有报错就可以开始初始化了.</p><p><img src="/images/check_install.png" alt=""></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>​    在任意位置新建一个文件夹用来存放博客文件, 然后在终端界面打开文件夹, 输入<code>hexo init</code>即可完成初始化 , 当看到<code>INFO  Start blogging with Hexo!</code>时表明初始化完成, 此时的项目结构如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml #项目配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   └── _posts #文章存放</span><br><span class="line">└── themes #存放主题</span><br></pre></td></tr></table></figure><p>​    运行<code>npm install</code>安装依赖, 然后就可以开始配置了.</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    项目的配置在_config.yml中进行, 用任意文本编辑器打开后, 需要自己根据自己的情况更新以下版块(每一部分可以通过搜索找到):</p><ul><li>site</li><li>URL</li></ul><p><code>url</code>填写自己在github上新建的库名的github pages网址就行了(<a href="https://yourrepository)" target="_blank" rel="noopener">https://yourrepository)</a>, 比如我的就是(<a href="https://yucklys.github.io)" target="_blank" rel="noopener">https://yucklys.github.io)</a>.</p><ul><li>Deployment<br><code>type</code>填写git, 然后填写repository和branch如下</li></ul><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">deploy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span></span><br><span class="line"><span class="hljs-attr">  repository:</span> <span class="hljs-string">git@github.com:Yucklys/yucklys.github.io.git</span></span><br><span class="line"><span class="hljs-attr">  branch:</span> <span class="hljs-string">master</span></span><br></pre></td></tr></table></figure><p>​    repository填写项目库SSH链接, 从项目库的clone or download选项中复制SSH链接然后粘贴, branch填写master.</p><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><p>​    终端输入<code>hexo g</code>生成页面, 结束后输入<code>hexo s</code>在本地服务器上显示页面, 默认端口是4000, 显示<code>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code>时打开浏览器, 输入localhost:4000并跳转即可看到自己的博客页以及初始的一个文章. </p><h3 id="上传repository"><a href="#上传repository" class="headerlink" title="上传repository"></a>上传repository</h3><p>​    首先全局声明自己身份, 在终端输入:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>​    在终端输入<code>cd ~/.ssh</code>, 如果返回”… No such file or directory ”, 则直接输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>(<strong>邮箱换成你的邮箱</strong>). 如果能进入ssh文件夹的话则输入<code>mkdir key_backup mv id_isa* key_backup</code>备份, 然后再输入<code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>.</p><p>​    可以一路回车, 如果想要每次输入密码的话, 也可以设置密码.</p><p>​    然后依次输入以下命令:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-agent -s</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>​    如果出错显示<code>Could not open a connection to your authentication agent</code>, 就输入</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure><p>​    之后输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>复制ssh key到剪切板. 在github用户设置界面可以看到<strong>SSH and GPG keys</strong>选项, 在该项下选择New SSH key, 随便写个名字, 然后将key粘贴到key中并保存. 之后在终端中输入<code>ssh -T git@github.com</code>查看是否成功添加, 有警告就一路yes, 出现<code>Hi username! You&#39;ve successfully authenticated, but Github does not provide shell access</code>说明添加成功.</p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>​    终端切换到博客文件夹, 输入<code>hexo d</code>部署, 显示<code>INFO  Deploy done: git</code>表明部署完成. 在浏览器中输入yucklys.github.io即可进入到博客界面了.</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    hexo的next主题最大的优点就是它的用户广泛, 所以大部分的功能都可以在<code>主题配置文件</code>中找到, 包含有完整的帮助文件以及众多next主题的大神用户自定义的方案, 可以说只需要<del>cv</del>简单模仿就可以做出一个不错的博客页. 当然写作的质量还是很关键的, 会用markdown是必不可少的一项技能, 这里可以去看一下hexo的<a href="https://hexo.io/zh-cn/docs/writing.html" target="_blank" rel="noopener">官方写作教程</a>, markdown的教程网上有许多, 善用google或百度.</p><p>​    <em>2018.11.4更新</em></p><p>现在使用的是<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">icarus</a>主题，换主题有两方面原因，一是<strong>icarus</strong>的确是一款很优秀的主题，二是<strong>next</strong>用的人实在是太多了，每次看别人的博客都有种撞衫的不爽感……</p>]]></content>
      
      <categories>
          
          <category> Customization </category>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello_world</title>
      <link href="/2018/06/29/hello-world/"/>
      <url>/2018/06/29/hello-world/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
  
  
</search>
